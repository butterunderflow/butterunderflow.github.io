<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Articles on Butter&#39;s space</title>
    <link>http://butter-xz.com/articles/</link>
    <description>Recent content in Articles on Butter&#39;s space</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <managingEditor>azhong.934@gmail.com (butterunderflow)</managingEditor>
    <webMaster>azhong.934@gmail.com (butterunderflow)</webMaster>
    <lastBuildDate>Tue, 05 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="http://butter-xz.com/articles/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Local Type Inference</title>
      <link>http://butter-xz.com/articles/20230901095515-local_type_inference/</link>
      <pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate>
      <author>azhong.934@gmail.com (butterunderflow)</author>
      <guid>http://butter-xz.com/articles/20230901095515-local_type_inference/</guid>
      <description>ML语言的背后 众所周知, ML系语言十分强大, 这不仅仅得益于它们丰富的语义(高阶函数, local binding, lambda), 还得益于这套语义背后强大的类型系统. ML语言的类型系统通常支持十分强大类型推导功能, 强大到什么程度呢? 理论上开发者可以忽略所有类型签名, type checker仍然可以推导出所有的类型签名.
类型推导的两个&amp;quot;端点&amp;quot; 但是, 如此强大的类型推导技术居然也不小心带来了一些负面影响:
重要的类型签名被忽略. 很多情况下, 类型签名并不是开发者的负担而是起到了 &amp;ldquo;verified document&amp;rdquo; 的作用, 对可读性有着关键的影响. 类型系统的复杂度增加(主要是类型推导部分). 直观来看这点是在语言实现上的负面影响, 但是过于复杂的类型推导除了会提升类型检查的复杂度也会带来编程的&amp;quot;负担&amp;quot;. 比如说开发者如果不能明确知道哪些类型能推导哪些类型不能推导, 那么考虑&amp;quot;要不要加上类型签名&amp;quot;的这个问题就会给程序员带来心智负担. 对于这些负面的影响, 最极端的做法就是我们要求把所有的类型都加上, 直接抛弃类型推导功能.
你不是说我推导不好吗, 那你自己写上吧.
但是这又带来了新的问题:
为所有类型写上类型签名实在是太啰嗦了, 维护一个冗长但是又没有意义的类型签名, 反而会带来编程时的心智负担. 很多类型签名实际上是&amp;quot;噪音&amp;quot;. 如果完全抛弃类型推导, 那么在一个程序中, 有可能类型签名比描述程序执行信息的核心部分还要多, 这样的类型噪音甚至反而会影响程序的可读性. 尝试找到类型推导平衡点 那么有没有一种办法设计一个类型系统, 可以在描述ML丰富的语义的同时引入&amp;quot;适量&amp;quot;的类型推导: 当显式写出类型签名的对开发者有益的时候不推导这个类型, 只选择推导&amp;quot;显式写出时无意义&amp;quot;的类型签名.
局部类型推导(Local-Type inference)技术就诞生了
作者总结了3种ML编程中常见的类型推导, 并通过局部类型推导技术完成这三种类型推导:
函数调用时类型参数的推导是必要的 匿名函数的类型推导是需要的 local binding的类型推导是需要的 局部类型推导(Local-Type inference) 局部类型推导尝试在保持ML编程的前提下尽可能的减弱类型推导的能力以简化类型推导算法, 局部的含义是类型推导只用到了局部的语法树的类型信息.
通过Local Type Argument Synthesis可以解决第一个问题, 通过双向类型检查(Bidirectional Type Checking)可以解决问题2, 3.
语言定义 先介绍了一个用于展示的简单的语言, 是沿用的一个叫 (Kernel F≤_) 的语言, 这个语言支持subtype, 参数化多态, 匿名函数, 局部绑定.</description>
      <content:encoded><![CDATA[<h2 id="ml语言的背后">ML语言的背后</h2>
<p><strong>众所周知</strong>, ML系语言十分强大, 这不仅仅得益于它们丰富的语义(高阶函数, local binding, lambda), 还得益于这套语义背后强大的类型系统.
ML语言的类型系统通常支持十分强大类型推导功能, 强大到什么程度呢?
理论上开发者可以忽略所有类型签名, type checker仍然可以推导出所有的类型签名.</p>
<h3 id="类型推导的两个-端点">类型推导的两个&quot;端点&quot;</h3>
<p>但是, 如此强大的类型推导技术居然也不小心带来了一些负面影响:</p>
<ol>
<li>重要的类型签名被忽略. 很多情况下, 类型签名并不是开发者的负担而是起到了 &ldquo;verified document&rdquo; 的作用, 对可读性有着关键的影响.</li>
<li>类型系统的复杂度增加(主要是类型推导部分).
直观来看这点是在语言实现上的负面影响,
但是过于复杂的类型推导除了会提升类型检查的复杂度也会带来编程的&quot;负担&quot;.
比如说开发者如果不能明确知道哪些类型能推导哪些类型不能推导,
那么考虑&quot;要不要加上类型签名&quot;的这个问题就会给程序员带来心智负担.</li>
</ol>
<p>对于这些负面的影响, 最极端的做法就是我们要求把所有的类型都加上, 直接抛弃类型推导功能.</p>
<blockquote>
<p>你不是说我推导不好吗, 那你自己写上吧.</p>
</blockquote>
<p>但是这又带来了新的问题:</p>
<ol>
<li>为所有类型写上类型签名实在是太啰嗦了, 维护一个冗长但是又没有意义的类型签名,
反而会带来编程时的心智负担.</li>
<li>很多类型签名实际上是&quot;噪音&quot;. 如果完全抛弃类型推导,
那么在一个程序中, 有可能类型签名比描述程序执行信息的核心部分还要多,
这样的类型噪音甚至反而会影响程序的可读性.</li>
</ol>
<h3 id="尝试找到类型推导平衡点">尝试找到类型推导平衡点</h3>
<p>那么有没有一种办法设计一个类型系统,
可以在描述ML丰富的语义的同时引入&quot;适量&quot;的类型推导:
当显式写出类型签名的对开发者有益的时候不推导这个类型,
只选择推导&quot;显式写出时无意义&quot;的类型签名.</p>
<p>局部类型推导(Local-Type inference)技术就诞生了</p>
<p>作者总结了3种ML编程中常见的类型推导, 并通过局部类型推导技术完成这三种类型推导:</p>
<ol>
<li>函数调用时类型参数的推导是必要的</li>
<li>匿名函数的类型推导是需要的</li>
<li>local binding的类型推导是需要的</li>
</ol>
<h2 id="局部类型推导--local-type-inference">局部类型推导(Local-Type inference)</h2>
<p>局部类型推导尝试在保持ML编程的前提下尽可能的减弱类型推导的能力以简化类型推导算法,
局部的含义是类型推导只用到了局部的语法树的类型信息.</p>
<p>通过Local Type Argument Synthesis可以解决第一个问题, 通过双向类型检查(Bidirectional Type Checking)可以解决问题2, 3.</p>
<h3 id="语言定义">语言定义</h3>
<p>先介绍了一个用于展示的简单的语言, 是沿用的一个叫 <em>(Kernel F</em>≤_) 的语言, 这个语言支持subtype, 参数化多态, 匿名函数, 局部绑定.</p>
<p>我觉得很有意思的一点是, 文中把同一个语言区分了两层: 分别是内部语言(internal language)和外部语言(external langauge).
内部语言是full typed language, 外部语言是程序员日常接触的语言是可以省略一些类型签名的.
而类型推导的过程就是把外部语言翻译成内部语言的过程. 这个隔离可以让&quot;推导了什么东西&quot;很清楚的展现.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-17_23-30-15_screenshot.png"
         alt="Figure 1: 内部语言的定义: 类型表达式, 表达式, 类型环境"/> <figcaption>
            <p><span class="figure-number">Figure 1: </span>内部语言的定义: 类型表达式, 表达式, 类型环境</p>
        </figcaption>
</figure>

<p>Bottom Type的引入可以让任意两个类型都有最大下界, 可以让类型推导总有解.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-17_23-35-40_screenshot.png"
         alt="Figure 2: 子类型规则"/> <figcaption>
            <p><span class="figure-number">Figure 2: </span>子类型规则</p>
        </figcaption>
</figure>

<p>需要注意这里是有forall类型的子类型关系的, 之后理解约束生成/求解规则需要用到.</p>
<ul>
<li>note: 参数类型也可以有forall, 那是不是说local type inference并没有rank-2 type的限制呢?</li>
</ul>
<h3 id="local-type-argument-synthesis">Local Type Argument Synthesis</h3>
<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-18_00-04-58_screenshot.png"
         alt="Figure 3: Declarative Rule"/> <figcaption>
            <p><span class="figure-number">Figure 3: </span>Declarative Rule</p>
        </figcaption>
</figure>

<p>这条规则的有2个要点: <br /></p>
<ol>
<li>如果调用目标的类型是 \( All(X)T \rightarrow R \), 并且调用的时候没有显式的给出类型参数, 那么需要通过推导 <strong>类型实参</strong>;</li>
<li>类型实参需要满足: 应用该类型实参后可以得到最小的函数返回类型.</li>
</ol>
<p>但是这条规则是声明式的, 为了能够得到一个可用的类型推导算法,
我们还要知道如何得到这个&quot;可以让返回值最小的类型实参&quot;.</p>
<p>于是就有了算法式规则.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-18_00-03-51_screenshot.png"
         alt="Figure 4: Algorithmic Rule"/> <figcaption>
            <p><span class="figure-number">Figure 4: </span>Algorithmic Rule</p>
        </figcaption>
</figure>

<p>该规则的算法含义是: 当需要infer \(f(\bar e)\) 的类型时, 我们需要做以下几件事情:</p>
<ol>
<li>先infer \(f\) 的类型;</li>
<li>infer 函数调用参数 \(e\) 的类型 \(\bar S\) ;</li>
<li>如果 \(f\) 的类型是一个需要类型参数的函数(即 \(|X| &gt; 0\)), 那么就需要类型推导推导出函数的类型参数;</li>
<li>把空集 \(\emptyset\), 类型 \(\bar S\), 形参类型 \(\bar S\),
类型形参 \(\bar X\), 喂给由关系 \(\vdash  \Rightarrow\) 定义的函数, 从而生成类型变量 \(\bar X\) 上的约束集合 \(\bar D\) ;</li>
<li>通过运算符 \(\wedge\) 合并 \(\bar D\) 得到 \(\bar C\) ;</li>
<li>求解约束 \(\bar C\) 得到能够让 \(R\) 最小的 unifier \(\sigma\)</li>
<li>将 \(\sigma\) 再apply到 \(\bar X\), 返回在internal term中填补空缺的类型实参.</li>
</ol>
<p>可以看到, 相比与声明式规则, 算法式规则中多了 \(C\) 和 \(\sigma\) .
其中 \(C\) 是在检查函数调用表达式时收集到的约束结合, \(\sigma\) 是对这些约束求解的结果.</p>
<ul>
<li>疑惑: 这里是不是有遗漏? 应该要像声明式规则一样把 <code>f</code> 翻译成 <code>f'</code> 的过程.</li>
</ul>
<p>很清晰对吧!</p>
<h4 id="约束生成">约束生成</h4>
<p>约束生成规则关系 \(V \vdash_{\bar X} S &lt;: T \Rightarrow D \), 描述了对于包含类型变量\(\bar X\)的子类型关系 \(S &lt;: T\)
和可以替换成任意类型的类型变量集合\(V\), 需要生成的关于 \(\bar X\) 类型约束集合 \(D\).
对于任意的 \(V\) 的替换都能满足  \(S &lt;: T\), 当且仅当 \(\bar X\) 满足类型约束 \(D\).</p>
<p>为什么要有一个 \(V\) 呢? 因为文章中用于展示的语言的类型并没有rank-2的限制,
当我们尝试为一个子类型关系生成约束时, 类型中有的变量是free的(我们需要生成约束的变量),
有的变量是被 \(ALL\) capture 的.
而对于这些captrured变量, 我们不知道关于它们的任何信息,
所以需要按照这个目标来生成free变量约束:
对于所有被capture的变量的替换, 子类型关系都能成立.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-30_14-34-25_screenshot.png"
         alt="Figure 5: 约束生成的关系"/> <figcaption>
            <p><span class="figure-number">Figure 5: </span>约束生成的关系</p>
        </figcaption>
</figure>

<p>这个关系中用到了两个辅助的关系 \(\Uparrow\) 和 \(\Downarrow\), 叫做 Variable Elimination. 这两个关系就不复杂了, 而且是完全对称的.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-30_15-27-55_screenshot.png"
         alt="Figure 6: Variable Elimination关系"/> <figcaption>
            <p><span class="figure-number">Figure 6: </span>Variable Elimination关系</p>
        </figcaption>
</figure>

<p>\(S \Uparrow^V T\) 表示对于类型 \(S\), \(T\) 是满足以下条件的最小上界类型: \(T\) 大于\(S&rsquo;\), \(S&rsquo;\)为任意把 \(S\) 中的 \(V\) 替换为任意类型后得到的类型.</p>
<p>原文中的描述更加简单, 就说要eliminate掉这些变量.</p>
<blockquote>
<p>In the constraint generation algorithm that we present in the next section, it will
sometimes be necessary to eliminate all occurrences of a certain set of variables
from a given type by promoting (or demoting) the type until we reach a supertype
(or subtype) in which these variables do not occur.</p>
</blockquote>
<h4 id="约束求解">约束求解</h4>
<p>约束生成将为\(\bar X\)中的每个变量生成一个上限和下限, 约束求解将给每个\(X\)一个具体的类型,
具体来说就是取能让返回类型最小的边界条件.</p>
<p>类型变量\(X\)在类型\(T\)中出现的位置可以分为4类covariant, invariant, contravariant和constant. 个人通俗的解释是:</p>
<ol>
<li>Covariant: 表示类型X增长, 类型T也会随之增长(如\(T = (&hellip;) \rightarrow X\));</li>
<li>Contravariant: 表示类型X增长, 类型T也法内容会随之下降 (如\(T = (&hellip; X &hellip;) \rightarrow &hellip;\));</li>
<li>Invariant: X发生变化为X&rsquo;后, 只要X与X&rsquo;不同, T&rsquo;与之前的T是不存在子类型关系的;</li>
<li>Constant: X随便替换成什么, 替换后的类型均有子类型关系.</li>
</ol>
<p>严谨的定义如下:</p>
<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-30_18-22-44_screenshot.png"
         alt="Figure 7: covariant, invariant, contravariant和constant"/> <figcaption>
            <p><span class="figure-number">Figure 7: </span>covariant, invariant, contravariant和constant</p>
        </figcaption>
</figure>

<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-30_17-58-07_screenshot.png"
         alt="Figure 8: 约束求解"/> <figcaption>
            <p><span class="figure-number">Figure 8: </span>约束求解</p>
        </figcaption>
</figure>

<p>因为有subtype的存在, 这里的约束求解与let polymorphism中的unification稍微有些不同, unification基于 \(=\) 约束得到unifier,
此处基于 \(\le\) 约束和类型变量在返回类型中所处的位置得到unifier.</p>
<h3 id="双向类型检查--bidirectional-checking">双向类型检查(Bidirectional Checking)</h3>
<p>双向类型检查更像是一种类型检查的风格,
把类型检查分为了两个过程: check和infer.</p>
<p>check过程是: &ldquo;已经有一个term出现在了一个需要类型T的上下文中,
我们需要check这个term是否真的为类型T&rdquo;; <br />
infer过程是: &ldquo;对于一个term, 不知道这个term所在的上下文需要什么类型,
我们需要在上下文中infer这个term的类型&rdquo;.</p>
<p>这也是Bidirectional名称的由来: 我们既可以通过check把类型信息传递给子节点,
也可以通过infer把类型信息传递给父节点.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-30_18-53-12_screenshot.png"
         alt="Figure 9: Bidirectional Checking的规则"/> <figcaption>
            <p><span class="figure-number">Figure 9: </span>Bidirectional Checking的规则</p>
        </figcaption>
</figure>

<p>从规则中可以看到, 每一个term分别有两条规则, 一类是C开头的check,
另一类是S开头的Synthesis(就是Infer).</p>
<p>比较复杂的是Application节点的check&amp;infer:</p>
<ol>
<li>只有在Application节点, check会调用infer推导调用目标的类型,
然后根据该类型再check调用参数的类型是否兼容,
类型信息就是这样被带到了函数调用的实际参数;</li>
<li>Abstraction的check过程就是利用了1的类型信息以推导函数的参数类型.</li>
</ol>
<p>从规则中我们也能看到相比与let-polymorphism的不足, 在Abstraction的infer中,
我们必须写出类型参数, local-type-inference是不支持自动推导泛型参数的.</p>
<h4 id="bidirectional">Bidirectional?</h4>
<p>相比与原版的let polymorphism, 对于推导let binding type annotation的能力是要弱很多的,
虽然Bidirectional checking这个词是被local type inference提出的,
但是我觉得类型推导算法实际上都有类似 &ldquo;bidirectional&rdquo; 的过程.</p>
<p>类型推导还是一个收集约束然后求解约束的过程,</p>
<p>比如说在HM类型系统中, 我们需要不断的基于类型约束更新类型环境(环境如果关联了语法树上的类型信息的话,
那么语法树上的类型信息也会被更新).
这不也可以算是 <code>environment &lt;-&gt; term</code> 之间的bidirectional吗:
在environment中检查term; 在检查的过程中将收集到的约束&quot;反馈&quot;给environment.</p>
<p>HM type system在类型检查的过程中无时无刻不在基于新发现的约束更新环境;
而local type inference不会在类型检查过程中更新类型环境, 只允许利用局部的类型信息进行推导.</p>
<h2 id="现实世界的编程语言">现实世界的编程语言</h2>
<p>目前看到的编程语言, 要么采用像Haskell和OCaml这样的全局类型推导, 要么采用局部类型推导(Java, Scala), 并且都没有超过rank-2的限制(也就是说从理论上来说, local type inference还可以做更多).
然而局部类型推导是没有像let-polymorphism这样 <em>泛化(generalize)</em> 一个函数的能力的,</p>
<p>最近出的MoonBit采用了一种以前从来没见过的方案, 我觉得挺机智:</p>
<ol>
<li>模块级别的函数必须手动标注类型;</li>
<li>局部函数可以具有类似let-polymorphism的能力</li>
</ol>
<p>这样即可以限制类型推导的实际开销(只要\(O(n^2)\)的n足够小, 那就和常量差不多), 又具有let-polymorphism.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>讨论主题的重要性</title>
      <link>http://butter-xz.com/articles/20230825121425-disscuss-on-mainline/</link>
      <pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate>
      <author>azhong.934@gmail.com (butterunderflow)</author>
      <guid>http://butter-xz.com/articles/20230825121425-disscuss-on-mainline/</guid>
      <description>最近经常和各类人高强度的讨论各种事情, 我在读研期间和经常需要线上/线下和我的导师讨论各种问题, 但是我也没有感受到像最近这样的疲惫感.
我总结了一下, 主要原因还是在于讨论的时候没有确立讨论主题问题, 比如说对于一个问题X的解决方案的讨论, x提出了A解决方法, y指出了A解决方法中存在的问题P. 在听到了这些问题后, 如果x认为应该继续采用A方法, 正常的做法首先应该是论证P的影响, 比如说:
P到底是否存在? P的影响有多大? 给问题X的解决造成了多大程度的负面影响? P是否是为了解决某个问题而必然引入的新问题? 如果P确实是一个不可忽视的问题, 然后应该讨论解决方法A的的&amp;quot;补救&amp;quot;措施:
能否修改方案A以弥补问题P? 是否需要重新设计方案B以同时解决问题X和问题P? 如果沟通不是按照这个步骤结构化的进行, 那么必然产生心智负担. 实际沟通中常常会有如下几种情况:
如果y提出问题P后, x通过与问题本身无关的方式否认这个问题, 比如说解决问题P不会成为我们的优势, 解决问题P也不会让别人更想用我们的产品. 这种情况相当于直接回避问题. 如果y是个负责的人, 必然会想方设法的说服x问题P的存在性. 另一方面这也会让y感觉到疲惫, 因为&amp;quot;问题P是否存在&amp;quot;和&amp;quot;解决问题P是否会成为优势&amp;quot;是两个十分不相同的事情, 所用到的知识也很有可能属于完全不同的领域, 而y在讨论前可能并没有准备好另一部分的知识. 如果x确认问题P的存在后, 但是并不直面这个问题P, 而是说谁谁的a,b,c方案是用类似于A方案这么解决的, 根本没事. 这就给y带来了心智负担: 如果y没有了解过a,b,c方案, 他还需要再去确认这些方案是否真的是如x所说, 如果不如x所说又要和x对这些a,b,c方案的做法进行对齐. 如果想用别人的方案来说明, 正常的做法应当是x首先尽量详细介绍一下a,b,c方案, 说服y这些方案确实是为了x而存在, 且真的与解法A存在同构. 最后一种情况, 也是最折磨人的情况: 那你搞一个方案解决问题X吧, 我只能想到这种解法. 工作中的分工是明确的, 此时如果y是个对产品负责的人, 必然会在自己的工作量基础上增加额外的工作量. </description>
      <content:encoded><![CDATA[<p>最近经常和各类人高强度的讨论各种事情,
我在读研期间和经常需要线上/线下和我的导师讨论各种问题,
但是我也没有感受到像最近这样的疲惫感.</p>
<p>我总结了一下, 主要原因还是在于讨论的时候没有确立讨论主题问题,
比如说对于一个问题X的解决方案的讨论, x提出了A解决方法,
y指出了A解决方法中存在的问题P.
在听到了这些问题后, 如果x认为应该继续采用A方法,
正常的做法首先应该是论证P的影响, 比如说:</p>
<ol>
<li>P到底是否存在?</li>
<li>P的影响有多大? 给问题X的解决造成了多大程度的负面影响?</li>
<li>P是否是为了解决某个问题而必然引入的新问题?</li>
</ol>
<p>如果P确实是一个不可忽视的问题, 然后应该讨论解决方法A的的&quot;补救&quot;措施:</p>
<ol>
<li>能否修改方案A以弥补问题P?</li>
<li>是否需要重新设计方案B以同时解决问题X和问题P?</li>
</ol>
<p>如果沟通不是按照这个步骤结构化的进行, 那么必然产生心智负担.
实际沟通中常常会有如下几种情况:</p>
<ol>
<li>如果y提出问题P后, x通过与问题本身无关的方式否认这个问题,
比如说解决问题P不会成为我们的优势, 解决问题P也不会让别人更想用我们的产品.
这种情况相当于直接回避问题. 如果y是个负责的人,
必然会想方设法的说服x问题P的存在性. 另一方面这也会让y感觉到疲惫,
因为&quot;问题P是否存在&quot;和&quot;解决问题P是否会成为优势&quot;是两个十分不相同的事情,
所用到的知识也很有可能属于完全不同的领域, 而y在讨论前可能并没有准备好另一部分的知识.</li>
<li>如果x确认问题P的存在后, 但是并不直面这个问题P, 而是说谁谁的a,b,c方案是用类似于A方案这么解决的, 根本没事.
这就给y带来了心智负担: 如果y没有了解过a,b,c方案, 他还需要再去确认这些方案是否真的是如x所说,
如果不如x所说又要和x对这些a,b,c方案的做法进行对齐.
如果想用别人的方案来说明, 正常的做法应当是x首先尽量详细介绍一下a,b,c方案, 说服y这些方案确实是为了x而存在, 且真的与解法A存在同构.</li>
<li>最后一种情况, 也是最折磨人的情况: 那你搞一个方案解决问题X吧, 我只能想到这种解法.
工作中的分工是明确的, 此时如果y是个对产品负责的人, 必然会在自己的工作量基础上增加额外的工作量.</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>Partial Evaluation for Functional Language</title>
      <link>http://butter-xz.com/articles/partial-evaluation-for-functional/</link>
      <pubDate>Wed, 30 Aug 2023 00:00:00 +0000</pubDate>
      <author>azhong.934@gmail.com (butterunderflow)</author>
      <guid>http://butter-xz.com/articles/partial-evaluation-for-functional/</guid>
      <description>partial evaluation 的第五章 Partial Evaluation for a First-Order Functional Language 的笔记.
前一章通过对一个简单的 flow chart (基本块) 语言的 partial evaluation 介绍了许多 partial evaluation 的概念技巧. 一个partial evaluation算法基本可以分为以下两步:
确定源程序每个程序点可以静态确定的状态(Binding Time Analysis); 依据这些静态状态, 把源程序的每个基本块&amp;quot;展开&amp;quot;到目标程序, 这些静态状态在目标程序中不再需要被计算, 而是直接&amp;quot;嵌入&amp;quot;到了目标程序中. 该目标程序被称之为&amp;quot;残差程序&amp;quot;(residual program). 那么对于更加复杂的语言应该如何做partial evaluation呢?
这一章的介绍了一门比flow chart稍微强大(同时也复杂)一点的语言, 叫做Scheme0, 并展示了如何对这个语言进行partial evaluation. Scheme0仍然是采用lisp的语法, 支持全局的函数定义, 不支持高阶函数(将函数绑定至临时变量/将函数作为参数传递/将函数作为返回值), 没有副作用.
从flow chart到Scheme0 在对Scheme0进行partial evaluation的过程中, 有哪些概念/技巧/思想是可以从flow chart语言的partial evaluation中复用的呢? 我们需不需要对一个新的语言从头设计partial evaluation算法呢?
所幸, 绝大部分都是相似且可以复用的, 下表展示了这些可以直接对应起来的概念. 还有一些其他partial evaluation中的概念Scheme0和Flow Chart是完全没有变化的.
Flow Chart Scheme0 解释 Program point Function&amp;rsquo;s entry Flow Chart的program point直接对应函数的入口, 是specialize过程中始终保留的东西 Global Variable Parameter Global Variable对应函数的Parameter, 也只有这里的静态值会&amp;quot;嵌入&amp;quot;至residual program Transition Compression Function&amp;rsquo;s Unfolding - Binding Time Analysis 通过抽象解释进行BTA 采用抽象解释的方式分析binding time, 此时抽象域为 参数 -&amp;gt; binding time 的partial mapping, 称之为 Binding Time Environment(BTEnv).</description>
      <content:encoded><![CDATA[<p><em>partial evaluation</em> 的第五章 <em>Partial Evaluation for a First-Order Functional Language</em> 的笔记.</p>
<p>前一章通过对一个简单的 flow chart (基本块) 语言的 partial evaluation 介绍了许多 partial
evaluation 的概念技巧. 一个partial evaluation算法基本可以分为以下两步:<br /></p>
<ol>
<li>确定源程序每个程序点可以静态确定的状态(Binding Time Analysis);</li>
<li>依据这些静态状态, 把源程序的每个基本块&quot;展开&quot;到目标程序,
这些静态状态在目标程序中不再需要被计算, 而是直接&quot;嵌入&quot;到了目标程序中.
该目标程序被称之为&quot;残差程序&quot;(residual program).</li>
</ol>
<p>那么对于更加复杂的语言应该如何做partial evaluation呢?</p>
<p>这一章的介绍了一门比flow chart稍微强大(同时也复杂)一点的语言, 叫做Scheme0,
并展示了如何对这个语言进行partial evaluation.
Scheme0仍然是采用lisp的语法, 支持全局的函数定义,
不支持高阶函数(将函数绑定至临时变量/将函数作为参数传递/将函数作为返回值), 没有副作用.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/Pasted-image-20221127220632.png"/> 
</figure>

<h2 id="从flow-chart到scheme0">从flow chart到Scheme0</h2>
<p>在对Scheme0进行partial evaluation的过程中,
有哪些概念/技巧/思想是可以从flow chart语言的partial evaluation中复用的呢? 我们需不需要对一个新的语言从头设计partial evaluation算法呢?</p>
<p>所幸, 绝大部分都是相似且可以复用的, 下表展示了这些可以直接对应起来的概念.
还有一些其他partial evaluation中的概念Scheme0和Flow Chart是完全没有变化的.</p>
<table>
<thead>
<tr>
<th>Flow Chart</th>
<th>Scheme0</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Program point</td>
<td>Function&rsquo;s entry</td>
<td>Flow Chart的program point直接对应函数的入口, 是specialize过程中始终保留的东西</td>
</tr>
<tr>
<td>Global Variable</td>
<td>Parameter</td>
<td>Global Variable对应函数的Parameter, 也只有这里的静态值会&quot;嵌入&quot;至residual program</td>
</tr>
<tr>
<td>Transition Compression</td>
<td>Function&rsquo;s Unfolding</td>
<td>-</td>
</tr>
</tbody>
</table>
<h2 id="binding-time-analysis">Binding Time Analysis</h2>
<h3 id="通过抽象解释进行bta">通过抽象解释进行BTA</h3>
<p>采用抽象解释的方式分析binding time, 此时抽象域为 <code>参数 -&gt; binding time</code> 的partial mapping,
称之为 <strong>Binding Time Environment(BTEnv)</strong>.
而binding time的序也十分简单, 就是 \(D \ge S\).</p>
<p>对于BTA的抽象解释, 分为了两种transfer function, 两种transfer function具有不同的含义:</p>
<ol>
<li>如何使用BTEnv: 在一个BTEnv中, 如何根据子表达式的binding time得到该表达式的binding bime</li>
<li>如何更新BTEnv: 对于在binding time environment t中求值的表达式e, 对于某个函数g的调用,
这个g的实参的binding time至少为多少.</li>
</ol>
<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-17_17-02-59_screenshot.png"/> 
</figure>

<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-17_17-32-37_screenshot.png"/> 
</figure>

<p>从Bottom出发(也就是把所有的参数都初始化为Static)不断的应用上面第二个transfer
function更新每个函数参数的BTEnv, 直到无法更新任何函数的BTEnv,
此时称抽象解释达到了不动点(fixpoint).</p>
<h3 id="通过类型系统对bta进行soundness-check">通过类型系统对BTA进行soundness check</h3>
<p>可以把Binding Time Annotation看作是一种类型签名,
然后通过类型系统检查程序Binding Time Annotation的soundness, 类型检查规则如下:</p>
<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-17_20-08-03_screenshot.png"/> 
</figure>

<p>注意, 这里只能 <strong>检查(check)</strong> 一个BTA是否sound,
而不能 <strong>推导(infer)</strong> 出一个程序的BTA,
因为上述规则没有 <strong>为没有Binding Time Annotation的程序生成Binding Time Annotation</strong> 的能力,</p>
<h3 id="通过binding-time-annotation提高specialization算法的效率">通过Binding Time Annotation提高Specialization算法的效率</h3>
<p>先前的Binding Time都是通过一种叫binding time envionment来表示的,
这种表示在概念上很简洁, 但是因为在使用在实际运用binding time做specialization的时候是很低效的,
因为要不断的查表来看某个变量是否是static的.</p>
<p>一种提高效率的技巧是先通过binding time做一次程序变换,
变换过程中为程序的每个节点加上binding time annotation来描述BTA的分析结果,
这样在specialization 的过程中就只要看这个annotation就可以了.</p>
<p>如下图所示, 每个表达式都有一个 <code>s</code> 或 <code>d</code> 来表示这个表达式是static还是dynamic的,
函数的参数列表也被拆分成了static和dynamic参数两部分.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-17_17-47-13_screenshot.png"/> 
</figure>

<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-17_17-47-46_screenshot.png"/> 
</figure>

<h2 id="specialization算法">Specialization算法</h2>
<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-17_17-54-03_screenshot.png"/> 
</figure>

<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-17_18-17-50_screenshot.png"/> 
</figure>

<p>这里和之前的flow chart是十分相似的, 由于有函数的存在, 我觉得算法的表达反而更简洁了,
直接看算法还是可以理解的, 由三个函数组成:</p>
<ol>
<li>一个主调函数specialize, 包含输入程序 <code>program</code> 和表示了入口函数的static参数的值 <code>vs_0</code> .</li>
<li>一个 <strong>很像</strong> 尾递归的函数 <code>complete</code> :
<ol>
<li>complete将返回对 <code>pending</code> 中的specialized function entry进行specialization的结果;</li>
<li><code>marked</code> 包含已经specialized program point</li>
<li><code>program</code> 表示源程序, 这个参数不会改变</li>
</ol>
</li>
<li>一个基于静态值对表达式进行程序变换的函数 <code>reduce</code> ,
<code>reduce</code> 的内容很多但并其实不是特别复杂, 有一点需要注意的是,
目前 <code>calls</code> 只会unfold dynamic parameter list为空的函数.
而 unfold strategy 其实可以很多样.</li>
</ol>
<!--listend-->
<ul>
<li>注意: BTA只区分参数是static还是dynamic,
而具体的static value的值只有在reduce函数中才会被求出.</li>
</ul>
<h2 id="static-bound-variation--the-trick">Static Bound Variation(The Trick)</h2>
<p>在对Scheme0进行partial evaluation的过程中也会遇到Static Bound Variation的问题:</p>
<blockquote>
<p>当一个值是依赖于动态值, 但是其取值范围是静态的, 应该如何利用这样的静态信息.</p>
</blockquote>
<p>解法也是相似的(The Trick), 对包含Static Bound Variation的程序进行一次程序变换,
对取值范围中的每一个值进行一次分支判定, 从而该Static Bound Variation就可以看作Static的,
增加了可specialize的内容.</p>
<p>Static Bound Variation是高质量的self-application的关键,
因为如果不这么做的话会丢失掉很多specialize的机会,
从而让self-application生成的程序生成十分trivial的residual program(即使从语义上来说是正确的).</p>
<p>在对scheme0进行PE的过程中, 因为我们选取的specialation单元是一个函数,
因此如果不想大改现有的算法的话, 需要对程序进行一些变换才能使用the trick.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-17_19-13-00_screenshot.png"/> 
</figure>

<ul>
<li>这是不是就是这个 <a href="https://www.zhihu.com/answer/371277506">知乎回答</a> 中提到的 <strong>partial evaluation friendly</strong> 的意思?</li>
</ul>
<h2 id="function-unfolding-strategy">Function Unfolding Strategy</h2>
<p>unfold 可以消除一些函数定义让residual program变得更简洁,
比如说下面的两种函数显然可以被unfold:</p>
<ol>
<li>一个函数什么也没做, 只是调用另一个函数;</li>
<li>一个函数只被调用过一次.</li>
</ol>
<p>之前提到的unfolding strategy只有在 <code>calls</code> 的目标没有动态参数的时候会进行unfold,
然而unfold strategy的其实可以是比较复杂的.
unfold strategy的最终目的还是为了提升residual程序的质量(比如说消除trivial function).
而在这个过程中,
有可能因为unfold反而降低了程序质量(产生了program duplication或computation duplication),
又有各种各样的trick.
这里就不详细介绍每个strategy了, 只介绍一些通用的unfolding strategy的基本要求:</p>
<ol>
<li>实参的计算存在副作用, 则需要保证这些副作用的顺序&amp;次数在unfold后的程序中不变;</li>
<li>要保证unfold策略能够停机, 不会无限的unfold;</li>
<li>尽量避免unfold过程中的program duplication和computation duplication.</li>
</ol>
<h2 id="related-notes-resource">Related Notes/Resource</h2>
<p><a href="https://www.itu.dk/people/sestoft/pebook/">ND.Jones&rsquo;s book</a>: Partial Evaluation的教材</p>
<p><a href="/articles/partial-evaluation/">Partial Evaluation</a>: Partial Evaluation的基本概念</p>
<p><a href="/articles/partial-evaluation-for-flow-chart/">Partial Evaluation For Flow Chart Langauge</a>: Flow chart语言的Partial Evaluation</p>
<p><a href="/404">Abstract Interpretation</a>: 抽象解释</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Partial Evaluation For Flow Chart Langauge</title>
      <link>http://butter-xz.com/articles/partial-evaluation-for-flow-chart/</link>
      <pubDate>Sat, 19 Nov 2022 00:00:00 +0000</pubDate>
      <author>azhong.934@gmail.com (butterunderflow)</author>
      <guid>http://butter-xz.com/articles/partial-evaluation-for-flow-chart/</guid>
      <description>partial evaluation 的第四章 Partial Evaluation for a Flow Chart Language 的笔记.
这一章介绍了一个叫做 Flow Chart 的语言, 是一个以基本块组成的语言. 然后通过这个语言实现了两个二村映射来介绍Partial Evaluation的技巧.
程序和状态 然后就是程序点和程序状态的概念: 程序点就是程序执行的位置, 程序状态指的是程序执行的状态, 具体的状态的值域取决于语义的定义. 这一点和静态分析里的定义是类似的.
程序的状态可能有很多, 但大部分的语言都可以通过 变量 - 值 的映射来表示. 其中对于每个 program point, 变量的值可以分为 static 和 dynamic 分为两类. static 表示变量的值可以在静态确定, 而 dynamic 的值只能在运行时确定. 将每个 program point 的变量区分为 static 和 dynamic 的过程叫做 division.
基于static程序状态做partial evaluation 这就引出了一个概念叫做 poly, 指的是基于输入和已知的程序点的 static 变量的值, 可以最大程度地确认多少程序点的 static 变量? 这个问题的求解结果可以通过一个由 程序点-static value 序对组成的集合来表示 poly. 这些 poly 就对应着residual program (specialized program) 的 program point.</description>
      <content:encoded><![CDATA[<p><em>partial evaluation</em> 的第四章 <em>Partial Evaluation for a Flow Chart
Language</em> 的笔记.</p>
<p>这一章介绍了一个叫做 <em>Flow Chart</em> 的语言, 是一个以基本块组成的语言.
然后通过这个语言实现了两个二村映射来介绍<a href="/articles/partial-evaluation/">Partial Evaluation</a>的技巧.</p>
<h2 id="程序和状态">程序和状态</h2>
<p>然后就是程序点和程序状态的概念: 程序点就是程序执行的位置,
程序状态指的是程序执行的状态, 具体的状态的值域取决于语义的定义.
这一点和静态分析里的定义是类似的.</p>
<p>程序的状态可能有很多, 但大部分的语言都可以通过 <code>变量 - 值</code> 的映射来表示.
其中对于每个 program point, 变量的值可以分为 static 和 dynamic 分为两类.
static 表示变量的值可以在静态确定, 而 dynamic 的值只能在运行时确定.
将每个 program point 的变量区分为 static 和 dynamic 的过程叫做
<em>division</em>.</p>
<h2 id="基于static程序状态做partial-evaluation">基于static程序状态做partial evaluation</h2>
<p>这就引出了一个概念叫做 <em>poly</em>, 指的是基于输入和已知的程序点的 static
变量的值, 可以最大程度地确认多少程序点的 static 变量?
这个问题的求解结果可以通过一个由 <code>程序点-static value</code> 序对组成的集合来表示 <em>poly</em>.
这些 <em>poly</em> 就对应着residual program (specialized program) 的 program point.</p>
<p>一个直觉的描述是: 对于 subject program 在每个 program point, 把这个
program point 对应的 basic block 根据不同的 static state
&ldquo;展开&quot;的结果就是 residual program; &ldquo;展开&quot;之后, static 的属性就&quot;嵌入&quot;到
<em>residual program</em> 中, 成为residual program的一部分了,
而不再通过subject program的属性来表达.</p>
<h2 id="division">division</h2>
<p><em>division</em> 指的是在做partial evaluation之前, 先把程序变量做一个Static和Dynamic的区分,
区分要满足 &ldquo;相合性(congruence)&rdquo;</p>
<p><em>division</em> 的结果并不一定是唯一的, 只要满足以下 congruent 条件就行:</p>
<blockquote>
<p>Any variable that depends on a dynamic variable must itself be dynamic.</p>
</blockquote>
<p>也就是标记为Static的变量不能依赖于Dynamic变量.</p>
<p>这个定义其实有一些抽象. 我们来设想一种场景, 对于一个循环中的变量,
第一次循环的值是确定的, 然后在循环中会通过赋值更新这个变量(这个 <em>Flow
Chart</em> 的语言是允许赋值的), 那么这个变量算是什么呢?</p>
<p>首先, 我们先看一下相合性本身的强大, 然后我们再来介绍一些更加高级的division方法</p>
<h3 id="强大的相合性-被赋过值的变量-也可以是-static">强大的相合性: &ldquo;被赋过值的变量&quot;也可以是&quot;Static&rdquo;</h3>
<p>比如说这个循环的循环次数和对变量更新的值都是可以确定的 (假设是 <code>k</code> 次),
那么把这个变量标记为Static是满足相合性的. <br />
一个简单的验证办法是我们可以把这个循环展开 <code>k</code> 次, 展开后的程序的循环变量显然都是 static 的.</p>
<p>但是如果每次循环对变量更新的值仍然是 static 的,
但是循环的次数可能有无限多次, 这个变量我们应该标记为 static 吗?</p>
<p>对于这种情况, 我们将变量标记为static是满足相合性的: <br />
给定任意的 k, 我们都能确定这个变量第 k 次循环的值. 但是,
把他们当作 static 的, subject program 的 <em>poly</em> 将会是无限的,
从而无法有效的计算出一个 residual program (程序都是有限的). 所以,
从计算residual program的角度来说, 有无限多种可能的 static variable
是没有意义的.</p>
<p>所以对于这种标记为 Static 满足相合性, 但是会导致在 partial
evaluation 的过程中会得到无限多状态的变量,  我们只选择性的把他们标记为 dynamic.</p>
<p>这样我们就得到了一种十分简单且对任何情况都适用的处理方式: <br />
所有麻烦的东西都当成 dynamic 就好了!
即使某些地方这个变量的值是已知的,
为了满足相合性, 我们直接直接将这个变量标记为Dynamic的,
这样虽然有一些静态信息我们没有利用, 但基于这样的division做partial
evalutaion仍然是安全的.</p>
<p>但是从 partial evaluation最基本的直觉出发, 我们标注为 dynamic 的东西越多,
我们能够 specialize 的东西就越少, partial evaluation 所能带来的优化也就更少.
所以, 我们的 <em>division</em> 应该在保证相合性和可计算性的前提下尽可能的让 dynamic 少.</p>
<p>那有没有什么通用的办法, 让我们给出 division 的同时, 还能保证这个
division 的 dynamic 是 <em>最少</em> 的?</p>
<p>很可惜, 这个问题是个 <em>不可判定</em> 问题.</p>
<p>不过书上说他们之后会给个办法给一个可接受的解(前面提到了, 合理的 division
并不唯一).</p>
<h3 id="更加高级的division">更加高级的division</h3>
<p>除了全程序共用一个division, 也有很多更加高级的division方式, 这又根据其目的分了不同的情况, 有的是为了利用更多的静态信息, 有的是为了生成更高质量的residual program.
不过基本思想都是把division进行&quot;参数化&rdquo;, 以表达更复杂的计算上下文中的static value. (这点和程序分析中的上下文敏感很相似)</p>
<h4 id="point-wise-division">Point-wise Division</h4>
<p>除了全程序共用一个division的方法, 还可以点对点(Point-wise)的设置division.
在这种division下, 每个程序点的division可以是不同的.</p>
<p>可以通过一个程序来说明pointwise的含义(书中的例子):</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">read(X, Y);
init: X := X + 1
      Y := Y - 1
cont: Y := 3
next: ...
</code></pre><p>如果程序的输入 <code>(X, Y)</code> 的init division是 <code>(S, D)</code>, 如果使用uniform division(全程序共用一个division)的话, 那么即使在next处 <code>Y</code> 的值明显是已知的, 也不能把他标记为Static的.</p>
<h4 id="polyvariant-division">Polyvariant Division</h4>
<p>Polyvariant的Division指的是: 一个division不仅仅和程序点有关, 还和程序如何执行到这个程序点有关. 对于一个变量, 有的执行路径下把它标注为Static, 有的路径标注为Dynamic. 这种division就可以很灵活了, 此时, division可以由一个 <code>flow -&gt; division</code> 的映射表示.</p>
<p>此时, 一个程序点可能对应多个division(之前的point-wise division是每个点对应 <strong>1</strong> 个), 所以叫 <strong>poly</strong> variant division(每个程序点对应1个的叫 <strong>mono</strong> variant division)</p>
<p>疑问: 那可不可以再更加灵活一点呢? 比如说通过 <code>flow -&gt; state -&gt; division</code> 表示, state是上一个程序点的状态.</p>
<h4 id="live-and-dead-division">Live and Dead Division</h4>
<p>目前的division只包含变量关于Static和Dynamic的划分.
但是有的时候, 这个变量在某个program point的值是static的,
但是这个变量在这个点没有被用到过(dead),
那我们可以在residual program的program point安全的抹去这些变量的值.</p>
<p>因此Live and Dead Division也可以看作是一种pointwise division,
前述的pointwise division是每个program point的static value可以不同,
Live and Dead Division是每个program point包含的static value也可以不同.</p>
<h2 id="transition-compression">Transition Compression</h2>
<p>路径压缩的目的是简化生成的residual program的质量, 消灭掉一些没有意义的跳转, 比如说生成的程序包含从一个基本块 <code>x := 1</code> 到基本块 <code>y := 1</code> 的跳转, 那么可以把这两个基本块直接合并成一个基本块. 其本身不会对生成程序的正确性和性能造成影响(这里的性能指的是抽象机中的性能, 真实的程序由于cache locality, 跳转的数量和距离都会对性能有影响).</p>
<p>需要注意的是, Transition Compression是有可能带来代码重复的. 比如说, 有两个基本块都跳转到统一个基本块, 但是我们把两个跳转都压缩了, 这就会带来代码重复. 需要谨慎的选择需要压缩的transition以避免代码爆炸的问题.</p>
<h2 id="mix算法">Mix算法</h2>
<p>Partial Evaluation一般要做以下几件事情: <br /></p>
<ol>
<li>根据输入, 确定变量的 division; 也就是把变量区分为 static 和 dynamic 两类.
这一步有的是和计算residual program的过程是合在一起的(online) <br /></li>
<li>基于division计算 poly, 也就是 specialized program 的 program points.
前面提到了, poly也有很多种不同的方式 <br /></li>
<li>根据 poly, 生成 specialized program<br /></li>
<li>(optional) transition compression<br /></li>
<li>(optional) relabel the program</li>
</ol>
<p>书中展示了一个完整的 mixer 程序, 做了上面的5件事情:</p>
<figure>
    <img loading="lazy" src="/ox-hugo/Pasted-image-20221121074932.png"/> 
</figure>

<p>虽然上面的所有事情这个mix程序都做了, 只是有一些操作是隐式的.
比如说transition compression, 没有一个过程叫做&quot;transition compression&rdquo;,
当遇到 <code>goto l</code> 的时候, 直接把要插入的basic block更新成 <code>l</code> 对应的基本块就可以了.</p>
<h3 id="第一二村映射">第一二村映射</h3>
<p>如 <a href="/articles/partial-evaluation/">Partial Evaluation</a> 中的描述, 第一二村映射指的是将一个 interpreter 在 interpreter 的输入程序上进行specialize, 将会得到一个可执行程序.</p>
<p>一个解释器的完整定义如下:</p>
<figure>
    <img loading="lazy" src="/ox-hugo/Pasted-image-20221120195636.png"/> 
</figure>

<p>一个简单的程序可以被该解释器解释的程序:</p>
<figure>
    <img loading="lazy" src="/ox-hugo/Pasted-image-20221120194634.png"/> 
</figure>

<p>传入mix后, 将得到一个 specialized的解释器</p>
<figure>
    <img loading="lazy" src="/ox-hugo/Pasted-image-20221120194652.png"/> 
</figure>

<p>Program point of target 和 (Program point, static variable) of interpreter 之间的对应关系:</p>
<figure>
    <img loading="lazy" src="/ox-hugo/Pasted-image-20221120195702.png"/> 
</figure>

<h3 id="第二二村映射">第二二村映射</h3>
<p>mix程序可以把 <code>program</code> specialize 到 <code>program</code> 的静态可确定的程序状态 <code>vs_0</code>.
但是mix程序本身不也是程序吗? 它的输入是 <code>program</code>, <code>division</code> 和 <code>vs_0</code>.</p>
<p>那么mix可不可以把 <code>program</code> 参数specialize到某个程序呢?</p>
<p>答案是可以的, 也就是mix程序具有 <strong>应用到自己(self-application)</strong> 能力!</p>
<p>把mix本身作为mix待specilize的程序,
然后把mix在解释器程序上specialize后就可以得到一个编译器,
这就是 <strong>第二二村映射</strong>.</p>
<h3 id="在mix中利用更加高级的division">在Mix中利用更加高级的division</h3>
<p>为了简单起见, 刚刚提到mix算法采用的是 <em>offline partial evaluation</em>,
也就是先 通过binding time analysis算出division(可以看到mix有一个division参数),
然后通过这个divison计算residual program, 这个division在整个程序中是始终不变的.</p>
<p>想要使用刚刚提到的更加高级的division, 我们需要对mix程序进行一些修改.</p>
<h4 id="在mix中使用point-wise-division">在mix中使用point-wise division</h4>
<p>在mix中使用point-wise division只需要把原来的division表示
改成一个记录了每个point的division的表就可以了.
每次需要知道某个program point <code>pp</code> 的division的时候 <code>lookup(pp, division)</code> 就可以了.</p>
<p>有了point-wise division, live and dead就十分简单了,
还是给每个让每个program point的division不同,
刚刚提到的point-wise division指的是对于每个program point,
&ldquo;哪些变量是Static, 哪些变量是Dynamic&quot;这一信息是不同的;
live and dead division指的是对于每个program point,
&ldquo;需要考虑哪些变量是Static或Dynamic&quot;这一信息不同.</p>
<h4 id="在mix中使用polyvariant-division">在mix中使用polyvariant division</h4>
<p>想要在mix算法中应用polyvariant有两种思路:</p>
<ol>
<li>在mix中加入 polyvariant division 的使用逻辑,
书中的做法是给原有的由 <code>(pp, vs)</code> (subject program point和static value组成的列表)
所表示的specialized program point再加上一个division component &ndash; <code>(pp, vs, div)</code>,
以表示这个program point是根据具体 <strong>哪个</strong> 来division来specialize的.
不仅如此, 如何选取specialized program point也有讲究, 不能直接像初版的mix一样直接把一个program point的后继加入到pending里了, 要根据当前点的divison来决定后继节点和后继节点相应的divisions.</li>
<li>通过polyvariant division先对程序进行一次变换, 得到一个有monovariant division的程序.</li>
</ol>
<h2 id="self-application成功的关键">Self-Application成功的关键</h2>
<p>刚刚提到了mix程序是具有通过self-application得到编译器的能力的,
但是如果我们简单的把写好的mix传给mix我们是得不到刚刚图示的编译器的,
虽然可以得到一个&quot;正确&quot;的编译器(只要mix程序的实现是正确的, 那么二村映射的含义也一定是正确的),
但这个编译器会有很多的问题, 图示的mix函数在背后把这些问题&quot;偷偷&quot;解决了,
只把最直观优雅的东西写了出来, 比如说以下内容, 图示算法没有显式的考虑:  <br /></p>
<ol>
<li>假设division已知, 而对于mix这样一个复杂的程序, division的分析并不容易.</li>
<li>一些base function有些过于强大了, 它们到底是什么? 我们应该把哪些东西作为base function,
把哪些东西自己把实现写到subject program中.</li>
<li>简单的binding time analysis所得到的static variable太少;
仅仅由相合性得到的division, 有很多静态信息没有利用到.</li>
<li>(pp, static value)序对有很多, 这会在residual program中生成超多的跳转标签(远多余图示的生成的编译器).</li>
</ol>
<p>这里仅仅介绍个人觉得比较有趣的第3点, 如何通过Bound Static Variation更多的静态信息(相比与仅满足相合性的程序而言).</p>
<p>对于其他技巧, 请参考 <a href="https://www.itu.dk/people/sestoft/pebook/">Partial Evaluation教材</a> 的 <em>4.8 The tricks under the carpet</em>.</p>
<h3 id="bound-static-variation--the-trick">Bound Static Variation(&ldquo;The Trick&rdquo;)</h3>
<p>我们在specialize一个程序的时候, 通常会遇到一个问题:
程序中一个变量的值依赖于动态的输入, 但是其范围是已知的.</p>
<p>比如说如下程序:</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">x = input()
array = [1,2,3]
t = mod(x, 3)
y = array[t]
</code></pre><p>我们希望对其进行specialization, x的值显然是Dynamic, array的值显然是Static,
那t的值依赖于x, 所以按照相合性, t必须被标记为dynamic.</p>
<p>但是与一般的Dynamic不同, 我们并不是完全不知道y的取值的, 这里y只能取 <code>1,2,3</code> 三种值.</p>
<p>对于这种 <strong>值无法确定(Static), 但是取值范围可以确定(Static)</strong> 的值,
我们可以通过一个程序变换, 在变换中直接将这个值消除掉, 从而利用 <strong>取值范围有限</strong> 这一静态信息.</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">x = input()
array = [1,2,3]
y = case t of
  | 1 -&gt; array[1]
  | 2 -&gt; array[2]
  | 3 -&gt; array[3]
</code></pre><p>(其实也就是为每个可能的取值生成一个case啦)</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Language and Interpreters</title>
      <link>http://butter-xz.com/articles/language-and-interpreters/</link>
      <pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate>
      <author>azhong.934@gmail.com (butterunderflow)</author>
      <guid>http://butter-xz.com/articles/language-and-interpreters/</guid>
      <description>partial evaluation 的第三章 Programming Languages and Interpreters 的笔记.
这一章主要是形式化的介绍了一下 Partial Evaluation 中的基本概念: 程序, 解释和编译.
程序只是一种表示, 程序的语义决定了程序的含义, 在这里程序的语义指的是 Operational Semantic, 具体指的是一套指导程序应该如何规约(reduction)的规则. 所有编程语言的语义隐式定义了一个用于执行程序的抽象机, 可以把抽象机看作是程序的&amp;quot;解释器&amp;quot;(有的资料也称之为&amp;quot;元解释器&amp;quot;, 但我还没想明白&amp;quot;元&amp;quot;在哪里), 这也是为什么说所有语言本质上都是解释执行的原因.
与直接用这个编程语言的抽象机来执行不同, 用另外一个程序来实现程序的语义可以称之为 解释执行, 解释器本身也是在某种抽象机上执行的. 对于某个目标程序 P, 解释器 int 在对应抽象机上的解释 P 的执行步数, 一般要比 P 在 P 对应的抽象机上的执行步数要成倍数的增长.
比如说对于一个变量的求值, 在代表程序语义的抽象机上一共只需要一步; 而在解释器中, 会*对应*到5步:
解释函数 (如 eval) 的调用
模式匹配判断当前表达式是一个变量
读取环境
读取变量名
读取环境中对应变量名的值 可以通过case by case的分析各种语义的对应步数得到一个大致的倍数, 从而估算解释的开销(overhead).
刚刚提到了开销, 这个开销实际上是不可以忽略的, 首先在真实世界的编程语言中, 这个开销的倍数可能非常大(比如说可能是几十倍); 另一方面, 当语言的实现涉及到多层中间表示的时候, 解释也会有多层, 那么这个开销的倍数也会相乘, 最终开销也会呈指数增长. 将源程序直接编译为可执行的程序(比如说机器指令)就是减少在开销上做乘法的一种思路(减少解释的开销). 这个过程也叫 lowering, 把更高层的表示 lowering 到底层的表示.</description>
      <content:encoded><![CDATA[<p><em>partial evaluation</em> 的第三章 <em>Programming Languages and Interpreters</em>
的笔记.</p>
<p>这一章主要是形式化的介绍了一下 <a href="/articles/partial-evaluation/">Partial Evaluation</a> 中的基本概念: 程序, 解释和编译.</p>
<p>程序只是一种表示, 程序的语义决定了程序的含义, 在这里程序的语义指的是
<em>Operational Semantic</em>,
具体指的是一套指导程序应该如何规约(reduction)的规则.
所有编程语言的语义隐式定义了一个用于执行程序的抽象机,
可以把抽象机看作是程序的&quot;解释器&quot;(有的资料也称之为&quot;元解释器&quot;,
但我还没想明白&quot;元&quot;在哪里),
这也是为什么说所有语言本质上都是解释执行的原因.</p>
<p>与直接用这个编程语言的抽象机来执行不同,
用另外一个程序来实现程序的语义可以称之为 <em>解释执行</em>,
解释器本身也是在某种抽象机上执行的. 对于某个目标程序 <code>P</code>, 解释器 <code>int</code>
在对应抽象机上的解释 <code>P</code> 的执行步数, 一般要比 <code>P</code> 在 <code>P</code>
对应的抽象机上的执行步数要成倍数的增长.<br />
比如说对于一个变量的求值, 在代表程序语义的抽象机上一共只需要一步;
而在解释器中, 会*对应*到5步:<br /></p>
<ol>
<li>解释函数 (如 <code>eval</code>) 的调用<br /></li>
<li>模式匹配判断当前表达式是一个变量<br /></li>
<li>读取环境<br /></li>
<li>读取变量名<br /></li>
<li>读取环境中对应变量名的值</li>
</ol>
<p>可以通过case by case的分析各种语义的对应步数得到一个大致的倍数,
从而估算解释的开销(overhead).</p>
<p>刚刚提到了开销, 这个开销实际上是不可以忽略的,
首先在真实世界的编程语言中,
这个开销的倍数可能非常大(比如说可能是几十倍); 另一方面,
当语言的实现涉及到多层中间表示的时候, 解释也会有多层,
那么这个开销的倍数也会相乘, 最终开销也会呈指数增长.
将源程序直接编译为可执行的程序(比如说机器指令)就是减少在开销上做乘法的一种思路(减少解释的开销).
这个过程也叫 <em>lowering</em>, 把更高层的表示 <em>lowering</em> 到底层的表示.</p>
<p>最后书上介绍了一下编译器自举(bootstrapping)的概念,
自举指的是一个compiler <code>h</code> 可以通过被其 compiled version <code>t</code> 编译,
并且得到 compiled version <code>t</code>.</p>
<p>现在发现其实很多介绍没有把这一点讲透, 很多人都说:
&ldquo;自举就是编译器可以编译自己.&rdquo; 让人感觉不到这其中的微妙之处:
&ldquo;自己编译自己有什么神奇的吗?&rdquo; 实际上更完整的描述应该是:
一个编译器(compiled version)可以通过编译自己(source)*得到自己*(compiled
version)</p>
<p>书上通过举了个例子说明如何通过扩展 <code>S</code> 语言实现的 <code>S</code>
语言的编译器并完成自举的过程:</p>
<p>首先我们已有 <code>S</code> 语言编译器的源码 <code>h</code> 和编译后的代码 <code>t</code>
<img loading="lazy" src="/ox-hugo/Pasted-image-20221108053150.png" alt=""  />
 1. 然后我们在 <code>h=上扩展, 得到了一个 =S'=的编译器 =h'</code>
<img loading="lazy" src="/ox-hugo/Pasted-image-20221108053354.png" alt=""  />
 2. 然后用一开始的 <code>t</code> 把
<code>h'</code> 编译, 得到 <code>t1'</code> <img loading="lazy" src="/ox-hugo/Pasted-image-20221108053451.png" alt=""  />
 3.
再用 <code>t1'</code> 编译一遍 <code>h'</code>. 这里第一次用了扩展后的编译器 <code>h'=的语义. =t1'</code>
也是h&rsquo;的compiled program, 但因为 <code>t1'</code>
不是由h&rsquo;的语义编译生成的(是由=h=的语义即 <code>t</code> 编译生成的).
所以这里还算不上自举 <img loading="lazy" src="/ox-hugo/Pasted-image-20221108053602.png" alt=""  />
 4.
最后用 <code>t2'=编译 =h'</code>, 这里就有了自举了. 因为 <code>t3'</code> 是完全等于 <code>t2'=的, 因为 =t1'=的语义和 =t2'</code> 的*语义*相同.
<img loading="lazy" src="/ox-hugo/Pasted-image-20221108053955.png" alt=""  />
</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Partial Evaluation</title>
      <link>http://butter-xz.com/articles/partial-evaluation/</link>
      <pubDate>Sat, 22 Oct 2022 00:00:00 +0000</pubDate>
      <author>azhong.934@gmail.com (butterunderflow)</author>
      <guid>http://butter-xz.com/articles/partial-evaluation/</guid>
      <description>Partial Evaluation 的第一章 Introduction 的笔记. 从抽象上来看, 程序都可以看作是一个输入到输出的函数. 如果输入可以拆分为多个的话, 那么如果程序的某个输入 in1 是可以提前确定的, 那么可以生成一个针对 in 优化的程序, 这个过程叫做specialization. 针对in1优化的&amp;quot;优化器&amp;quot;可以叫做spacializer. 所以Partial Evaluation实际上可以看作做了两件事情: 1. 提前计算可以预先知道的输入 2. 为提前知道的输入进行特化版本的程序
如果是解释器的话, 那么一个解释器可以通过下图描述:
+--------+ P --&amp;gt; | interp | --&amp;gt; out input --&amp;gt; | | +--------+ 如果有了一个interpreter, 有了一个针对解释器的源程序输入的specializer, 那么就得到了一个可执行程序. 用图画出来就是这样, PE 就是我们的specializer.
图1:
+----+ interp --&amp;gt; | PE | --&amp;gt; interpP P --&amp;gt; | | +----+ 那么也可以看到, 这个specialzer本身也是多参数的函数, 那么如果我们已经有了一个specialzer, 如果再把这个specializer对interp参数进行specialization, 我们就可以得到一个编译器(图中的PEinterp).
图2:
+----+ PE --&amp;gt; | PE | --&amp;gt; PEinterp interp --&amp;gt; | | +----+ 这里的PE又是一个多参数的函数, 我们又可以对其进行Specialization.</description>
      <content:encoded><![CDATA[<p><em>Partial Evaluation</em> 的第一章 <em>Introduction</em> 的笔记. 从抽象上来看,
程序都可以看作是一个输入到输出的函数. 如果输入可以拆分为多个的话,
那么如果程序的某个输入 <code>in1</code> 是可以提前确定的,
那么可以生成一个针对 <code>in</code> 优化的程序, 这个过程叫做specialization.
针对in1优化的&quot;优化器&quot;可以叫做spacializer. 所以Partial
Evaluation实际上可以看作做了两件事情: 1. 提前计算可以预先知道的输入 2.
为提前知道的输入进行特化版本的程序</p>
<p>如果是解释器的话, 那么一个解释器可以通过下图描述:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>           +--------+
</span></span><span style="display:flex;"><span>P      --&gt; | interp | --&gt; out
</span></span><span style="display:flex;"><span>input  --&gt; |        |
</span></span><span style="display:flex;"><span>           +--------+
</span></span></code></pre></div><p>如果有了一个interpreter, 有了一个针对解释器的源程序输入的specializer,
那么就得到了一个可执行程序. 用图画出来就是这样,
<code>PE</code> 就是我们的specializer.</p>
<p>图1:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>           +----+
</span></span><span style="display:flex;"><span>interp --&gt; | PE | --&gt; interpP
</span></span><span style="display:flex;"><span>     P --&gt; |    |
</span></span><span style="display:flex;"><span>           +----+
</span></span></code></pre></div><p>那么也可以看到, 这个specialzer本身也是多参数的函数,
那么如果我们已经有了一个specialzer,
如果再把这个specializer对interp参数进行specialization,
我们就可以得到一个编译器(图中的PEinterp).</p>
<p>图2:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>           +----+
</span></span><span style="display:flex;"><span>PE     --&gt; | PE | --&gt; PEinterp
</span></span><span style="display:flex;"><span>interp --&gt; |    |
</span></span><span style="display:flex;"><span>           +----+
</span></span></code></pre></div><p>这里的PE又是一个多参数的函数, 我们又可以对其进行Specialization.
如果有一个Specialzer, 可以让PE对PE进行进行Specialization,
那么就可以得到一个编译器的生成器(图中的PE_PE).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>        +----+
</span></span><span style="display:flex;"><span>PE  --&gt; | PE | --&gt; PE_PE
</span></span><span style="display:flex;"><span>PE  --&gt; |    |
</span></span><span style="display:flex;"><span>        +----+
</span></span></code></pre></div><p>这里的每个PE的输入都是两个程序,
其中一个程序 <code>in1</code> 是另外一个程序 <code>in2</code> 的输入;
PE的功能都是为 <code>in2</code> 生成一个特化在 <code>in1</code> 的版本,
这个特化的版本往往会比 <code>in1 |&gt; in2</code> 更加高效.</p>
<p>有个关键的概念需要区分: program text和running program</p>
<p>Partial Evaluation和Partial Application还是很不一样的 在Partial
Application中, 得到的是一个同一个语言的函数; 而partial evaluation中,
得到的是一个*新的程序* <img loading="lazy" src="/images/image-20221023232021.png" alt=""  />

这里就要理解一个program text和一个正在运行的程序的区别, program
text只是程序的表示, 而运行起来的程序才能抽象成一个函数.
可以通过语义函数(图中的双中括号)把程序从program text转变成函数.</p>
<p>比如说, 我们说PE的输入是程序,
但是图中的PE的类型可以看作 <code>L</code> (因为PE是程序的表示),
通过语义函数变成类型为 <code>L -&gt; L -&gt; L</code> 的函数, 其中 <code>L</code> 是程序表示的类型.</p>
<p>然后粗略的读了一下第二章, 主要是一些概念的介绍.
从集合论的角度介绍了一下类型还有一些类型上的运算(sum, product
type),以及一些类型推导的简要介绍.
我觉得有一个关键是强调了 <code>program</code> 和 <code>function</code> 之间的区别:
program是一个syntactic world里的东西, 比如说符号, 表达式,
function是数学意义上的东西.</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
