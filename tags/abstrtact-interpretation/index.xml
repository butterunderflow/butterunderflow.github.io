<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Abstrtact-Interpretation on Butter&#39;s space</title>
    <link>http://butter-xz.com/tags/abstrtact-interpretation/</link>
    <description>Recent content in Abstrtact-Interpretation on Butter&#39;s space</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <managingEditor>azhong.934@gmail.com (butterunderflow)</managingEditor>
    <webMaster>azhong.934@gmail.com (butterunderflow)</webMaster>
    <lastBuildDate>Sat, 02 Mar 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://butter-xz.com/tags/abstrtact-interpretation/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Partial Evaluation for Lambda Calculus</title>
      <link>http://butter-xz.com/articles/20231111153704-partial_evaluation_for_lambda_calculus/</link>
      <pubDate>Sat, 02 Mar 2024 00:00:00 +0000</pubDate>
      <author>azhong.934@gmail.com (butterunderflow)</author>
      <guid>http://butter-xz.com/articles/20231111153704-partial_evaluation_for_lambda_calculus/</guid>
      <description>这是 [1] 第 8 章 Partial Evaluation for Lambda Calculus 的笔记.
在 Partial Evaluation for Functional Language 和 Partial Evaluation For Flow Chart Langauge 中, partial evaluation 所 eval 的东西很直观, 就是一个具体的像 int, bool 这样具体的值, 没有考虑高阶函数.
但是对于有高阶函数的语言, 情况变得复杂, 因为一个表达式的求值结果可能是一个函数, 那么考虑一个简单的场景, 返回一个常量的函数, 应该标记为是 Static 还是 Dynamic ? 比如: (lambda (x) 1)
如果标记为 S, 那这个函数在 residual program 中对应什么? 似乎也只能是 (lambda (x) 1) 如果标记为 D, 为什么一个这么简单的函数会返回一个常量的函数需要标记为 D? 是不是对于 lambda 表达式 partial evaluation 都无能为力? 我会有这样的疑惑主要有两个原因:</description>
      <content:encoded><![CDATA[<p>这是 <a href="#citeproc_bib_item_1">[1]</a> 第 8 章 <em>Partial Evaluation for Lambda Calculus</em> 的笔记.</p>
<p>在 <a href="/articles/partial-evaluation-for-functional/">Partial Evaluation for Functional Language</a> 和 <a href="/articles/partial-evaluation-for-flow-chart/">Partial Evaluation For Flow Chart Langauge</a> 中,
partial evaluation 所 eval 的东西很直观, 就是一个具体的像 int, bool 这样具体的值, 没有考虑高阶函数.</p>
<p>但是对于有高阶函数的语言, 情况变得复杂, 因为一个表达式的求值结果可能是一个函数,
那么考虑一个简单的场景, 返回一个常量的函数, 应该标记为是 Static 还是 Dynamic ?
比如: <code>(lambda (x) 1)</code></p>
<ol>
<li>如果标记为 S, 那这个函数在 residual program 中对应什么? 似乎也只能是 <code>(lambda (x) 1)</code></li>
<li>如果标记为 D, 为什么一个这么简单的函数会返回一个常量的函数需要标记为 D?
是不是对于 lambda 表达式 partial evaluation 都无能为力?</li>
</ol>
<p>我会有这样的疑惑主要有两个原因:</p>
<ol>
<li>之前提到的 S 和 D 这样简单的 annotation 的标记对于简单的语言是足够的, 但是对于存在高阶函数的语言,
需要更丰富的 binding time annotation 才能描述&quot;编译期函数&quot;和&quot;运行时函数&quot;;</li>
<li>标记为 D 和 S 的表达式都不一定会出现在最终的 residual program 中, 在有高阶函数的语言,
residual program 长什么样主要看 partial evaluation 的结果,
之前的 &ldquo;Dynamic 表达式作为程序骨架, Static 表达式求值后嵌入程序骨架&rdquo; 的基本直觉失效了.</li>
</ol>
<p>本文将介绍 lambda calculus 的 partial evaluation.
首先将定义一个简单的 lambda calculus, 然后介绍它的 binding time annotation 和 annotated version,
最后再分别展示它的 Binding Time Analysis(由 lambda calculus 得到 Annotated Program)和
具体的 staging(由 annotated program 得到 residual program)算法.</p>
<ul>
<li>本文所有代码都将用 OCaml 演示, 代码仓库在 <a href="https://github.com/butterunderflow/lambda_pe">https://github.com/butterunderflow/lambda_pe</a> ,
可以在这里 <a href="https://butter-xz.com/lambda_pe/">https://butter-xz.com/lambda_pe/</a> 在线体验 Lambda Calculus 的 Partial Evaluation;</li>
<li>有时候 Lambda Calulus 会被简写成 LC, Partial Evaluation 会被简写为 PE,
Binding Time Analysis 会被简写为 BTA.</li>
</ul>
<h2 id="lambda-calculus-的语法">Lambda-calculus 的语法</h2>
<p>labmda 表达式的语法定义如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#75715e">(* expr1.ml, level 1 expression*)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> expr <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">|</span> <span style="color:#a6e22e">EInt</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">|</span> <span style="color:#a6e22e">EVar</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">|</span> <span style="color:#a6e22e">ELam</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">*</span> expr
</span></span><span style="display:flex;"><span><span style="color:#f92672">|</span> <span style="color:#a6e22e">ELet</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">*</span> expr <span style="color:#f92672">*</span> expr
</span></span><span style="display:flex;"><span><span style="color:#f92672">|</span> <span style="color:#a6e22e">EApp</span> <span style="color:#66d9ef">of</span> expr <span style="color:#f92672">*</span> expr
</span></span></code></pre></div><h2 id="binding-time-annotation--for-lambda-calculus">Binding Time Annotation(for Lambda Calculus)</h2>
<p>有 partial evaluation 的语言有个 two-level type system, two-level 的意思是,
一个 level 对应编程语言原来的类型系统, 另一个就对应这个 annotation.</p>
<p>在之前章节里关于 Binding Time Annotation 的一个比较直观的理解是:
标记为 S 会被 eval 成值, D 会在 residual program 中被保留成代码.</p>
<ul>
<li>这还是比较好理解的, 但是 <code>D -&gt; S</code> 呢? <code>D -&gt; S -&gt; S</code> &hellip; 呢? 它们代表什么?</li>
</ul>
<p>Binding time annotation 和一般的 type annotation 很类似,
只不过他不是描述 <strong><strong>运行时(run time)</strong></strong> 类型信息的, 而是描述 <strong><strong>partial evaluation time</strong></strong> 的类型信息的,
这个类型信息只做了 code 和 value 的区分, 具体的 code 和 value 又有它们自己在 first-level 的类型.</p>
<p>这个标记的所描述的是 pe-time 过程中的类型信息,
标记为 D(ynamic) 的表达式在 pe 过程中会被求值为 code, 标记为 S(tatic) 的会被求值为 value,
标记为 <code>D -&gt; S</code> 的表达式在 specialize 过程中会转换为由 code 到 value 函数,
但是它们并不代表 residual program 中的最终形态.
也就是说, 标记为 S 和 D 的表达式都不一定会出现在 residual program 中.</p>
<h2 id="annotated-program--for-lambda-calculus">Annotated Program(for Lambda Calculus)</h2>
<p>Annotated Program 对应一个语言的 Two-level syntax</p>
<figure>
    <img loading="lazy" src="/ox-hugo/2023-11-19_18-16-54_screenshot.png"
         alt="Figure 1: two-level syntax for Scheme0"/> <figcaption>
            <p><span class="figure-number">Figure 1: </span>two-level syntax for Scheme0</p>
        </figcaption>
</figure>

<figure>
    <img loading="lazy" src="/ox-hugo/2023-11-15_09-33-00_screenshot.png"
         alt="Figure 2: Lambda calculus 的 two-level syntax"/> <figcaption>
            <p><span class="figure-number">Figure 2: </span>Lambda calculus 的 two-level syntax</p>
        </figcaption>
</figure>

<p>带有 S 标记的表示这个表达式在 pe 过程中会 eval 到 value(可能是一般的值或函数值),
带有 D 标记的则会 eval 到 code.</p>
<ul>
<li>note: variable 没有标记, variable 的 pe 结果是从当前的 environment 中 lookup 的结果.</li>
</ul>
<!--listend-->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#75715e">(* expr2.ml, level 2 expression *)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> expr <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">(* use variable lookup as specialize result *)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Var</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">(* specialize to a value(a pe time int or function value) *)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#a6e22e">SConst</span> <span style="color:#66d9ef">of</span> constant
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#a6e22e">SLam</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">*</span> expr
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#a6e22e">SLet</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">*</span> expr <span style="color:#f92672">*</span> expr
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#a6e22e">SApp</span> <span style="color:#66d9ef">of</span> expr <span style="color:#f92672">*</span> expr
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">(* specialize to a pe-time code expression *)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#a6e22e">DLam</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">*</span> expr
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#a6e22e">DLet</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">*</span> expr <span style="color:#f92672">*</span> expr
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#a6e22e">DApp</span> <span style="color:#66d9ef">of</span> expr <span style="color:#f92672">*</span> expr
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#a6e22e">DLift</span> <span style="color:#66d9ef">of</span> expr
</span></span><span style="display:flex;"><span><span style="color:#f92672">[@@</span>deriving sexp<span style="color:#f92672">]</span>
</span></span></code></pre></div><h2 id="binding-time-analysis">Binding Time Analysis</h2>
<p>LC 的 Binding Time Analysis 就是把 LC 编译到 2LC 的过程, 我们可以这样定义 BTA 的接口:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#66d9ef">module</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">BTA_Sig</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">sig</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">val</span> analysis <span style="color:#f92672">:</span> Expr1.expr <span style="color:#f92672">-&gt;</span> Expr2.expr
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><h3 id="naive-bta">Naive BTA</h3>
<p>BTA 是一个比较泛的概念, 并没有唯一正确的做法, 比如说什么都不干,
把所有东西都当作 Dynamic 也是一种可行的 BTA:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">NaiveBTA</span> <span style="color:#f92672">:</span> <span style="color:#a6e22e">BTA_Sig</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">(* blindly push every thing to runtime *)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> analysis <span style="color:#f92672">(</span>e <span style="color:#f92672">:</span> E1.expr<span style="color:#f92672">)</span> <span style="color:#f92672">:</span> E2.expr <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">rec</span> go e <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">match</span> e <span style="color:#66d9ef">with</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> E1.<span style="color:#a6e22e">EConst</span> c <span style="color:#f92672">-&gt;</span> E2.<span style="color:#a6e22e">SConst</span> c
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> E1.<span style="color:#a6e22e">EVar</span> x <span style="color:#f92672">-&gt;</span> E2.<span style="color:#a6e22e">Var</span> x
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> E1.<span style="color:#a6e22e">ELam</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> e0<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> E2.<span style="color:#a6e22e">DLam</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> go e0<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> E1.<span style="color:#a6e22e">ELet</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> e0<span style="color:#f92672">,</span> e1<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> E2.<span style="color:#a6e22e">DLet</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> go e0<span style="color:#f92672">,</span> go e1<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> E1.<span style="color:#a6e22e">EApp</span> <span style="color:#f92672">(</span>e0<span style="color:#f92672">,</span> e1<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> E2.<span style="color:#a6e22e">DApp</span> <span style="color:#f92672">(</span>go e0<span style="color:#f92672">,</span> go e1<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    go e
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><h3 id="naive-bta">Naive BTA'</h3>
<p>另一个极端是把所有东西都当作 static, 这么做当然也是可行的(只是没什么意义):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#75715e">(* blindly stage every thing to compile time *)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> analysis <span style="color:#f92672">(</span>e <span style="color:#f92672">:</span> E1.expr<span style="color:#f92672">)</span> <span style="color:#f92672">:</span> E2.expr <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">rec</span> go e <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> e <span style="color:#66d9ef">with</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> E1.<span style="color:#a6e22e">EConst</span> c <span style="color:#f92672">-&gt;</span> E2.<span style="color:#a6e22e">SConst</span> c
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> E1.<span style="color:#a6e22e">EVar</span> x <span style="color:#f92672">-&gt;</span> E2.<span style="color:#a6e22e">Var</span> x
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> E1.<span style="color:#a6e22e">ELam</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> e0<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> E2.<span style="color:#a6e22e">SLam</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> go e0<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> E1.<span style="color:#a6e22e">ELet</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> e0<span style="color:#f92672">,</span> e1<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> E2.<span style="color:#a6e22e">SLet</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> go e0<span style="color:#f92672">,</span> go e1<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> E1.<span style="color:#a6e22e">EApp</span> <span style="color:#f92672">(</span>e0<span style="color:#f92672">,</span> e1<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> E2.<span style="color:#a6e22e">SApp</span> <span style="color:#f92672">(</span>go e0<span style="color:#f92672">,</span> go e1<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> E1.<span style="color:#a6e22e">EAnn</span> <span style="color:#f92672">(</span>e0<span style="color:#f92672">,</span> <span style="color:#f92672">_)</span> <span style="color:#f92672">-&gt;</span> go e0
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> E1.<span style="color:#a6e22e">EOp</span> <span style="color:#f92672">(</span>op<span style="color:#f92672">,</span> es<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> E2.<span style="color:#a6e22e">SOp</span> <span style="color:#f92672">(</span>op<span style="color:#f92672">,</span> List.map go es<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>  go e
</span></span></code></pre></div><h3 id="bta-by-type-check">BTA by type check</h3>
<p>前面两个 NaiveBTA 是&quot;对&quot; 的吗? 当然是对的, 但是这其实没有意义, 因为我们没办法对 annotated program 做 staging
(staging nothing 和 staging everything).</p>
<p>前面提到了, BTA 的结果是不唯一的, 既然不唯一, 那要如何选择一个表达式的 annotation 呢?</p>
<p>比如说下面的代码, f 既 apply 到了 1(a static)上, 又 apply 到了 y(a dynamic)上, 如何确定 f 的 annotation?
很多种可行解.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">fun</span> x <span style="color:#f92672">-&gt;</span> x <span style="color:#66d9ef">in</span>  <span style="color:#75715e">(* f: D; D-&gt;D; S-&gt;S; (S-&gt;S) -&gt; (S-&gt;S) ... *)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span> f 1 <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span> f y <span style="color:#f92672">...</span> <span style="color:#75715e">(* y is dynamic *)</span>
</span></span></code></pre></div><p>如果我们只看 <code>f 1</code> , 那么 <code>f</code> 只能是 <code>S -&gt; 'a</code>, <code>D</code> , <code>D -&gt; 'a</code> (1可以被lift为Dynamic);
如果只看 <code>f y</code>, 那么 <code>f</code> 只能是 <code>D -&gt; 'a</code>, <code>D</code> .</p>
<p>书上介绍了一种约束收集+求解的方法, 定义了一个 annotation 上的偏序关系,
然后通过求解收集到的约束得到最小的解.</p>
<p>这个方法太复杂了, 一堆偏序关系头都要晕了, 如果有感兴趣的话可以看 <a href="#citeproc_bib_item_1">[1]</a> 的 <code>8.7 BTA by solving constraints</code> .</p>
<p>这里选择另一种简单点的方法作为实现.
首先, 为了让 bta 变得简单, 我们给 LC1 加上一个 binding time annotation 注解的语法,
让我们可以手动的为表达式添加 annotation.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#f92672">and</span> expr <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#a6e22e">EConst</span> <span style="color:#66d9ef">of</span> constant
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#a6e22e">EVar</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#a6e22e">ELam</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">*</span> expr
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#a6e22e">ELet</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">*</span> expr <span style="color:#f92672">*</span> expr
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#a6e22e">EApp</span> <span style="color:#66d9ef">of</span> expr <span style="color:#f92672">*</span> expr
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#a6e22e">EAnn</span> <span style="color:#66d9ef">of</span> expr <span style="color:#f92672">*</span> Ann.t <span style="color:#75715e">(* Binding time annotation hint *)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#a6e22e">EOp</span> <span style="color:#66d9ef">of</span> op <span style="color:#f92672">*</span> expr <span style="color:#66d9ef">list</span>
</span></span></code></pre></div><p>然后用 ML 类型推导的方式(不需要偏序关系, 仅仅需要等价关系)推导一个表达式的 Binding Time Annotation,
根据这个 Annotation 来得到 level 2 expression.</p>
<p>这里我们借用 <a href="/articles/20230901095515-local_type_inference/">Local Type Inference</a> 中 bidirectional type checking 的思路,
把 bta 分为两种 mode:</p>
<ol>
<li>check mode: 已知一个表达式的 annotation <code>a</code>, 验证这个表达式的 annotation 是否等于 <code>a</code>;</li>
<li>infer mode: 对表达式的 annotation 一无所知, 需要推导这个表达式的 annotation.</li>
</ol>
<p>bidirectional type checking 可以把已经推导出的类型信息传递到相邻的语法树节点,
使得我们可以仅仅只写少量的 binding time annotation 注解就可以推导所有节点的 annotation.</p>
<p>具体的代码实现如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">rec</span> infer <span style="color:#f92672">(</span>e <span style="color:#f92672">:</span> E1.expr<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>env <span style="color:#f92672">:</span> ann_env<span style="color:#f92672">)</span> <span style="color:#f92672">:</span> E2.expr <span style="color:#f92672">*</span> ann <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">match</span> e <span style="color:#66d9ef">with</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> E1.<span style="color:#a6e22e">EConst</span> c <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">(</span>E2.<span style="color:#a6e22e">SConst</span> c<span style="color:#f92672">,</span> <span style="color:#a6e22e">S</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> E1.<span style="color:#a6e22e">EVar</span> x <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">(</span>E2.<span style="color:#a6e22e">Var</span> x<span style="color:#f92672">,</span> get x env<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> E1.<span style="color:#a6e22e">ELam</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> e0<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> failwith <span style="color:#e6db74">&#34;can&#39;t infer a lambda&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> E1.<span style="color:#a6e22e">ELet</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> e0<span style="color:#f92672">,</span> e1<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">let</span> e0&#39;<span style="color:#f92672">,</span> a0&#39; <span style="color:#f92672">=</span> infer e0 env <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">match</span> a0&#39; <span style="color:#66d9ef">with</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#a6e22e">D</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">(</span>E2.<span style="color:#a6e22e">DLet</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> e0&#39;<span style="color:#f92672">,</span> check e1 Ann.<span style="color:#a6e22e">D</span> <span style="color:#f92672">((</span>x<span style="color:#f92672">,</span> a0&#39;<span style="color:#f92672">)</span> <span style="color:#f92672">::</span> env<span style="color:#f92672">)),</span> <span style="color:#a6e22e">D</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">let</span> e1&#39;<span style="color:#f92672">,</span> a1&#39; <span style="color:#f92672">=</span> infer e1 <span style="color:#f92672">((</span>x<span style="color:#f92672">,</span> a0&#39;<span style="color:#f92672">)</span> <span style="color:#f92672">::</span> env<span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">(</span>E2.<span style="color:#a6e22e">SLet</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> e0&#39;<span style="color:#f92672">,</span> e1&#39;<span style="color:#f92672">),</span> a1&#39;<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> E1.<span style="color:#a6e22e">EApp</span> <span style="color:#f92672">(</span>e0<span style="color:#f92672">,</span> e1<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">let</span> e0&#39;<span style="color:#f92672">,</span> a0&#39; <span style="color:#f92672">=</span> infer e0 env <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">match</span> a0&#39; <span style="color:#66d9ef">with</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#a6e22e">S</span> <span style="color:#f92672">-&gt;</span> failwith <span style="color:#e6db74">&#34;error&#34;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#a6e22e">D</span> <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">let</span> e1&#39; <span style="color:#f92672">=</span> check e1 Ann.<span style="color:#a6e22e">D</span> env <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">(</span>E2.<span style="color:#a6e22e">DApp</span> <span style="color:#f92672">(</span>e0&#39;<span style="color:#f92672">,</span> e1&#39;<span style="color:#f92672">),</span> Ann.<span style="color:#a6e22e">D</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#a6e22e">Func</span> <span style="color:#f92672">(</span>arg_ann<span style="color:#f92672">,</span> ret_ann<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">let</span> e1&#39; <span style="color:#f92672">=</span> check e1 arg_ann env <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">(</span>E2.<span style="color:#a6e22e">SApp</span> <span style="color:#f92672">(</span>e0&#39;<span style="color:#f92672">,</span> e1&#39;<span style="color:#f92672">),</span> ret_ann<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> E1.<span style="color:#a6e22e">EAnn</span> <span style="color:#f92672">(</span>e0<span style="color:#f92672">,</span> a0<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">(</span>check e0 a0 env<span style="color:#f92672">,</span> a0<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> E1.<span style="color:#a6e22e">EOp</span> <span style="color:#f92672">(</span>op<span style="color:#f92672">,</span> es<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">match</span> <span style="color:#f92672">(</span>op<span style="color:#f92672">,</span> es<span style="color:#f92672">)</span> <span style="color:#66d9ef">with</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#a6e22e">OAdd</span><span style="color:#f92672">,</span> <span style="color:#f92672">[</span> e0<span style="color:#f92672">;</span> e1 <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#a6e22e">OMinus</span><span style="color:#f92672">,</span> <span style="color:#f92672">[</span> e0<span style="color:#f92672">;</span> e1 <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#a6e22e">OAnd</span><span style="color:#f92672">,</span> <span style="color:#f92672">[</span> e0<span style="color:#f92672">;</span> e1 <span style="color:#f92672">]</span> <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">let</span> e0&#39;<span style="color:#f92672">,</span> a0&#39; <span style="color:#f92672">=</span> infer e0 env <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">let</span> e1&#39; <span style="color:#f92672">=</span> check e1 a0&#39; env <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">(</span>E2.<span style="color:#a6e22e">SOp</span> <span style="color:#f92672">(</span>op<span style="color:#f92672">,</span> <span style="color:#f92672">[</span> e0&#39;<span style="color:#f92672">;</span> e1&#39; <span style="color:#f92672">]),</span> a0&#39;<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#a6e22e">ONot</span><span style="color:#f92672">,</span> <span style="color:#f92672">[</span> e0 <span style="color:#f92672">]</span> <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">let</span> e0&#39;<span style="color:#f92672">,</span> a0&#39; <span style="color:#f92672">=</span> infer e0 env <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">(</span>E2.<span style="color:#a6e22e">SOp</span> <span style="color:#f92672">(</span>op<span style="color:#f92672">,</span> <span style="color:#f92672">[</span> e0&#39; <span style="color:#f92672">]),</span> <span style="color:#a6e22e">D</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> failwith <span style="color:#e6db74">&#34;neverreach&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">and</span> check <span style="color:#f92672">(</span>e <span style="color:#f92672">:</span> E1.expr<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>a <span style="color:#f92672">:</span> ann<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>env <span style="color:#f92672">:</span> ann_env<span style="color:#f92672">)</span> <span style="color:#f92672">:</span> E2.expr <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">match</span> e <span style="color:#66d9ef">with</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> E1.<span style="color:#a6e22e">ELam</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> e0<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> check_lambda x e0 a env
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">let</span> e&#39;<span style="color:#f92672">,</span> a&#39; <span style="color:#f92672">=</span> infer e env <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> a&#39; <span style="color:#f92672">=</span> a <span style="color:#66d9ef">then</span> e&#39;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> a&#39; <span style="color:#f92672">=</span> <span style="color:#a6e22e">S</span> <span style="color:#f92672">&amp;&amp;</span> a <span style="color:#f92672">=</span> <span style="color:#a6e22e">D</span> <span style="color:#66d9ef">then</span> E2.<span style="color:#a6e22e">DLift</span> e&#39;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span> failwith <span style="color:#e6db74">&#34;error&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">and</span> check_lambda x e a env <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">match</span> a <span style="color:#66d9ef">with</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#a6e22e">S</span> <span style="color:#f92672">-&gt;</span> failwith <span style="color:#e6db74">&#34;error lambda annotation&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#a6e22e">D</span> <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">let</span> e&#39; <span style="color:#f92672">=</span> check e <span style="color:#a6e22e">D</span> <span style="color:#f92672">((</span>x<span style="color:#f92672">,</span> <span style="color:#a6e22e">D</span><span style="color:#f92672">)</span> <span style="color:#f92672">::</span> env<span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>      E2.<span style="color:#a6e22e">DLam</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> e&#39;<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Func</span> <span style="color:#f92672">(</span>arg_ann<span style="color:#f92672">,</span> ret_ann<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">let</span> e&#39; <span style="color:#f92672">=</span> check e ret_ann <span style="color:#f92672">((</span>x<span style="color:#f92672">,</span> arg_ann<span style="color:#f92672">)</span> <span style="color:#f92672">::</span> env<span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>      E2.<span style="color:#a6e22e">SLam</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> e&#39;<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> analysis <span style="color:#f92672">(</span>e <span style="color:#f92672">:</span> E1.expr<span style="color:#f92672">)</span> <span style="color:#f92672">:</span> E2.expr <span style="color:#f92672">=</span> infer e empty_env <span style="color:#f92672">|&gt;</span> fst
</span></span></code></pre></div><h2 id="staging">Staging!</h2>
<blockquote>
<p>万事俱备, 只欠 staging.</p>
</blockquote>
<p>LC 的 two-level syntax 类似于之前在 partial evaluation for Scheme0 提到的 <a href="/articles/partial-evaluation-for-functional/#通过binding-time-annotation提高specialization算法的效率">Binding Time Annotation</a> ,
但是在值域上有所差异:</p>
<ol>
<li>Scheme0 的值域只能是 Constant 所在的值域(称之为 Const);</li>
<li>lambda calculus 的值域可以是高阶函数:
高阶函数的值域(2FuncVal)是很丰富的:
不仅可以是 \(Const \rightarrow Cosnt\) 的函数;
可以是 \(2FuncVal \rightarrow 2FuncVal\);
还可以是 \(Code\) &hellip; .</li>
</ol>
<p>在做完 BTA 后, staging 的实现就很简单了, LC2 的 staging 其实也可以看作 two-level lambda calculus(2LC)的 interpreter!
只是在值域上有所差异, 这个 2LC 的值域在 LC 的基础上加上了 Code,
对于 2LC 表达式的求值结果可能是:</p>
<ol>
<li>求值到 Const 或 FuncVal, 代表这个表达式已经求值完了;</li>
<li>还可能求值到一个 Code, 这个 Code 等之后再去算.</li>
</ol>
<p>dlambda 的 body 也必须求值到 code, 然后再通过 build-lambda 创建一个动态求知 lambda 表达式.
但是这里为什么要用 <code>newname</code>? 书上说是为了避免 confusion,
我理解这个完全是为了 residual program 可读性和 specialize 算法的可维护性考虑的, 就算不重命名也不会导致 bug.</p>
<p>staging的代码实现如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">rec</span> eval <span style="color:#f92672">(</span>e <span style="color:#f92672">:</span> expr<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>env <span style="color:#f92672">:</span> env<span style="color:#f92672">)</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">value</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">match</span> e <span style="color:#66d9ef">with</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">|</span> <span style="color:#a6e22e">Var</span> x <span style="color:#f92672">-&gt;</span> List.assoc x env
</span></span><span style="display:flex;"><span><span style="color:#f92672">|</span> <span style="color:#a6e22e">DLam</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> e<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> new_var <span style="color:#f92672">=</span> gen_var <span style="color:#f92672">~</span>hint<span style="color:#f92672">:</span>x <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">VCode</span> <span style="color:#f92672">(</span>E1.<span style="color:#a6e22e">ELam</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> eval e <span style="color:#f92672">((</span>x<span style="color:#f92672">,</span> <span style="color:#a6e22e">VCode</span> new_var<span style="color:#f92672">)</span> <span style="color:#f92672">::</span> env<span style="color:#f92672">)</span> <span style="color:#f92672">|&gt;</span> get_code<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">|</span> <span style="color:#a6e22e">DLet</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> e0<span style="color:#f92672">,</span> e1<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> updated_env <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> <span style="color:#a6e22e">VCode</span> <span style="color:#f92672">(</span>E1.<span style="color:#a6e22e">EVar</span> x<span style="color:#f92672">))</span> <span style="color:#f92672">::</span> env <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">VCode</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">(</span><span style="color:#66d9ef">match</span> eval e0 env <span style="color:#66d9ef">with</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#a6e22e">VCode</span> code <span style="color:#f92672">-&gt;</span> E1.<span style="color:#a6e22e">ELet</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> code<span style="color:#f92672">,</span> eval e1 updated_env <span style="color:#f92672">|&gt;</span> get_code<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#a6e22e">VConst</span> c <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>          E1.<span style="color:#a6e22e">ELet</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> E1.<span style="color:#a6e22e">EConst</span> c<span style="color:#f92672">,</span> eval e1 updated_env <span style="color:#f92672">|&gt;</span> get_code<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#a6e22e">VFun</span> f <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>          E1.<span style="color:#a6e22e">ELet</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">(</span> x<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>              f <span style="color:#f92672">(</span><span style="color:#a6e22e">VCode</span> <span style="color:#f92672">(</span>E1.<span style="color:#a6e22e">EVar</span> <span style="color:#e6db74">&#34;_x&#34;</span><span style="color:#f92672">))</span> <span style="color:#f92672">|&gt;</span> get_code<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>              eval e1 updated_env <span style="color:#f92672">|&gt;</span> get_code <span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">|</span> <span style="color:#a6e22e">DApp</span> <span style="color:#f92672">(</span>e0<span style="color:#f92672">,</span> e1<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">VCode</span> <span style="color:#f92672">(</span>E1.<span style="color:#a6e22e">EApp</span> <span style="color:#f92672">(</span>eval e0 env <span style="color:#f92672">|&gt;</span> get_code<span style="color:#f92672">,</span> eval e1 env <span style="color:#f92672">|&gt;</span> get_code<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">|</span> <span style="color:#a6e22e">DLift</span> e <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> get_int <span style="color:#f92672">(</span>eval e env<span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">VCode</span> <span style="color:#f92672">(</span>E1.<span style="color:#a6e22e">EConst</span> v<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">|</span> <span style="color:#a6e22e">SConst</span> c <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">VConst</span> c
</span></span><span style="display:flex;"><span><span style="color:#f92672">|</span> <span style="color:#a6e22e">SLam</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> e<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">VFun</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> v <span style="color:#f92672">-&gt;</span> eval e <span style="color:#f92672">((</span>x<span style="color:#f92672">,</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">::</span> env<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">|</span> <span style="color:#a6e22e">SLet</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> e0<span style="color:#f92672">,</span> e1<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> bind_value <span style="color:#f92672">=</span> eval e0 env <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    eval e1 <span style="color:#f92672">((</span>x<span style="color:#f92672">,</span> bind_value<span style="color:#f92672">)</span> <span style="color:#f92672">::</span> env<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">|</span> <span style="color:#a6e22e">SApp</span> <span style="color:#f92672">(</span>e0<span style="color:#f92672">,</span> e1<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> func <span style="color:#f92672">=</span> get_func <span style="color:#f92672">(</span>eval e0 env<span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    eval e1 env <span style="color:#f92672">|&gt;</span> func
</span></span></code></pre></div><h2 id="thinking">thinking</h2>
<p>Offline PE 中 annotated language(比如 2LC) 和 typeset language 的是否会存在某种同构?</p>
<h2 id="references">References</h2>
<style>.csl-left-margin{float: left; padding-right: 0em;}
 .csl-right-inline{margin: 0 0 0 1em;}</style><div class="csl-bib-body">
  <div class="csl-entry"><a id="citeproc_bib_item_1"></a>
    <div class="csl-left-margin">[1]</div><div class="csl-right-inline">N. D. Jones, C. K. Gomard, and P. Sestoft, <i>Partial Evaluation and Automatic Program Generation</i>. USA: Prentice-Hall, Inc., 1993.</div>
  </div>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>Partial Evaluation for Functional Language</title>
      <link>http://butter-xz.com/articles/partial-evaluation-for-functional/</link>
      <pubDate>Wed, 30 Aug 2023 00:00:00 +0000</pubDate>
      <author>azhong.934@gmail.com (butterunderflow)</author>
      <guid>http://butter-xz.com/articles/partial-evaluation-for-functional/</guid>
      <description>partial evaluation 的第五章 Partial Evaluation for a First-Order Functional Language 的笔记.
前一章通过对一个简单的 flow chart (基本块) 语言的 partial evaluation 介绍了许多 partial evaluation 的概念技巧. 一个partial evaluation算法基本可以分为以下两步:
确定源程序每个程序点可以静态确定的状态(Binding Time Analysis); 依据这些静态状态, 把源程序的每个基本块&amp;quot;展开&amp;quot;到目标程序, 这些静态状态在目标程序中不再需要被计算, 而是直接&amp;quot;嵌入&amp;quot;到了目标程序中. 该目标程序被称之为&amp;quot;残差程序&amp;quot;(residual program). 那么对于更加复杂的语言应该如何做partial evaluation呢?
这一章的介绍了一门比flow chart稍微强大(同时也复杂)一点的语言, 叫做Scheme0, 并展示了如何对这个语言进行partial evaluation. Scheme0仍然是采用lisp的语法, 支持全局的函数定义, 不支持高阶函数(将函数绑定至临时变量/将函数作为参数传递/将函数作为返回值), 没有副作用.
从flow chart到Scheme0 在对Scheme0进行partial evaluation的过程中, 有哪些概念/技巧/思想是可以从flow chart语言的partial evaluation中复用的呢? 我们需不需要对一个新的语言从头设计partial evaluation算法呢?
所幸, 绝大部分都是相似且可以复用的, 下表展示了这些可以直接对应起来的概念. 还有一些其他partial evaluation中的概念Scheme0和Flow Chart是完全没有变化的.
Flow Chart Scheme0 解释 Program point Function&amp;rsquo;s entry Flow Chart的program point直接对应函数的入口, 是specialize过程中始终保留的东西 Global Variable Parameter Global Variable对应函数的Parameter, 也只有这里的静态值会&amp;quot;嵌入&amp;quot;至residual program Transition Compression Function&amp;rsquo;s Unfolding - Binding Time Analysis 通过抽象解释进行BTA 采用抽象解释的方式分析binding time, 此时抽象域为 参数 -&amp;gt; binding time 的partial mapping, 称之为 Binding Time Environment(BTEnv).</description>
      <content:encoded><![CDATA[<p><em>partial evaluation</em> 的第五章 <em>Partial Evaluation for a First-Order Functional Language</em> 的笔记.</p>
<p>前一章通过对一个简单的 flow chart (基本块) 语言的 partial evaluation 介绍了许多 partial
evaluation 的概念技巧. 一个partial evaluation算法基本可以分为以下两步:<br /></p>
<ol>
<li>确定源程序每个程序点可以静态确定的状态(Binding Time Analysis);</li>
<li>依据这些静态状态, 把源程序的每个基本块&quot;展开&quot;到目标程序,
这些静态状态在目标程序中不再需要被计算, 而是直接&quot;嵌入&quot;到了目标程序中.
该目标程序被称之为&quot;残差程序&quot;(residual program).</li>
</ol>
<p>那么对于更加复杂的语言应该如何做partial evaluation呢?</p>
<p>这一章的介绍了一门比flow chart稍微强大(同时也复杂)一点的语言, 叫做Scheme0,
并展示了如何对这个语言进行partial evaluation.
Scheme0仍然是采用lisp的语法, 支持全局的函数定义,
不支持高阶函数(将函数绑定至临时变量/将函数作为参数传递/将函数作为返回值), 没有副作用.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/Pasted-image-20221127220632.png"/> 
</figure>

<h2 id="从flow-chart到scheme0">从flow chart到Scheme0</h2>
<p>在对Scheme0进行partial evaluation的过程中,
有哪些概念/技巧/思想是可以从flow chart语言的partial evaluation中复用的呢? 我们需不需要对一个新的语言从头设计partial evaluation算法呢?</p>
<p>所幸, 绝大部分都是相似且可以复用的, 下表展示了这些可以直接对应起来的概念.
还有一些其他partial evaluation中的概念Scheme0和Flow Chart是完全没有变化的.</p>
<table>
<thead>
<tr>
<th>Flow Chart</th>
<th>Scheme0</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Program point</td>
<td>Function&rsquo;s entry</td>
<td>Flow Chart的program point直接对应函数的入口, 是specialize过程中始终保留的东西</td>
</tr>
<tr>
<td>Global Variable</td>
<td>Parameter</td>
<td>Global Variable对应函数的Parameter, 也只有这里的静态值会&quot;嵌入&quot;至residual program</td>
</tr>
<tr>
<td>Transition Compression</td>
<td>Function&rsquo;s Unfolding</td>
<td>-</td>
</tr>
</tbody>
</table>
<h2 id="binding-time-analysis">Binding Time Analysis</h2>
<h3 id="通过抽象解释进行bta">通过抽象解释进行BTA</h3>
<p>采用抽象解释的方式分析binding time, 此时抽象域为 <code>参数 -&gt; binding time</code> 的partial mapping,
称之为 <strong>Binding Time Environment(BTEnv)</strong>.
而binding time的序也十分简单, 就是 \(D \ge S\).</p>
<p>对于BTA的抽象解释, 分为了两种transfer function, 两种transfer function具有不同的含义:</p>
<ol>
<li>如何使用BTEnv: 在一个BTEnv中, 如何根据子表达式的binding time得到该表达式的binding bime</li>
<li>如何更新BTEnv: 对于在binding time environment t中求值的表达式e, 对于某个函数g的调用,
这个g的实参的binding time至少为多少.</li>
</ol>
<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-17_17-02-59_screenshot.png"/> 
</figure>

<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-17_17-32-37_screenshot.png"/> 
</figure>

<p>从Bottom出发(也就是把所有的参数都初始化为Static)不断的应用上面第二个transfer
function更新每个函数参数的BTEnv, 直到无法更新任何函数的BTEnv,
此时称抽象解释达到了不动点(fixpoint).</p>
<h3 id="通过binding-time-annotation提高specialization算法的效率">通过Binding Time Annotation提高Specialization算法的效率</h3>
<p>先前的Binding Time都是通过一种叫binding time envionment来表示的,
这种表示在概念上很简洁, 但是因为在使用在实际运用binding time做specialization的时候是很低效的,
因为要不断的查表来看某个变量是否是static的.</p>
<p>一种提高效率的技巧是先通过binding time做一次程序变换,
变换过程中为程序的每个节点加上binding time annotation来描述BTA的分析结果,
这样在specialization 的过程中就只要看这个annotation就可以了.</p>
<p>如下图所示, 每个表达式都有一个 <code>s</code> 或 <code>d</code> 来表示这个表达式是static还是dynamic的,
函数的参数列表也被拆分成了static和dynamic参数两部分. <code>lift</code> 表示dynamic表达式中的static部分.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-17_17-47-13_screenshot.png"/> 
</figure>

<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-17_17-47-46_screenshot.png"/> 
</figure>

<h3 id="通过类型系统对bta进行soundness-check">通过类型系统对BTA进行soundness check</h3>
<p>可以把Binding Time Annotation看作是一种类型签名,
然后通过类型系统检查程序Binding Time Annotation的soundness, 类型检查规则如下:</p>
<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-17_20-08-03_screenshot.png"/> 
</figure>

<p>注意, 这里只能 <strong>检查(check)</strong> 一个BTA是否sound,
而不能 <strong>推导(infer)</strong> 出一个程序的BTA,
因为上述规则没有 <strong>为没有Binding Time Annotation的程序生成Binding Time Annotation</strong> 的能力,</p>
<h2 id="specialization算法">Specialization算法</h2>
<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-17_17-54-03_screenshot.png"/> 
</figure>

<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-17_18-17-50_screenshot.png"/> 
</figure>

<p>这里和之前的flow chart是十分相似的, 由于有函数的存在, 我觉得算法的表达反而更简洁了,
直接看算法还是可以理解的, 由三个函数组成:</p>
<ol>
<li>一个主调函数specialize, 包含输入程序 <code>program</code> 和表示了入口函数的static参数的值 <code>vs_0</code> .</li>
<li>一个 <strong>很像</strong> 尾递归的函数 <code>complete</code> :
<ol>
<li>complete将返回对 <code>pending</code> 中的specialized function entry进行specialization的结果;</li>
<li><code>marked</code> 包含已经specialized program point</li>
<li><code>program</code> 表示源程序, 这个参数不会改变</li>
</ol>
</li>
<li>一个基于静态值对表达式进行程序变换的函数 <code>reduce</code> ,
<code>reduce</code> 的内容很多但并其实不是特别复杂, 有一点需要注意的是,
目前 <code>calls</code> 只会unfold dynamic parameter list为空的函数.
而 unfold strategy 其实可以很多样.</li>
</ol>
<!--listend-->
<ul>
<li>注意: BTA只区分参数是static还是dynamic,
而具体的static value的值只有在reduce函数中才会被求出.</li>
</ul>
<h2 id="static-bound-variation--the-trick">Static Bound Variation(The Trick)</h2>
<p>在对Scheme0进行partial evaluation的过程中也会遇到Static Bound Variation的问题:</p>
<blockquote>
<p>当一个值是依赖于动态值, 但是其取值范围是静态的, 应该如何利用这样的静态信息.</p>
</blockquote>
<p>解法也是相似的(The Trick), 对包含Static Bound Variation的程序进行一次程序变换,
对取值范围中的每一个值进行一次分支判定, 从而该Static Bound Variation就可以看作Static的,
增加了可specialize的内容.</p>
<p>Static Bound Variation是高质量的self-application的关键,
因为如果不这么做的话会丢失掉很多specialize的机会,
从而让self-application生成的程序生成十分trivial的residual program(即使从语义上来说是正确的).</p>
<p>在对scheme0进行PE的过程中, 因为我们选取的specialation单元是一个函数,
因此如果不想大改现有的算法的话, 需要对程序进行一些变换才能使用the trick.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/2023-09-17_19-13-00_screenshot.png"/> 
</figure>

<ul>
<li>这是不是就是这个 <a href="https://www.zhihu.com/answer/371277506">知乎回答</a> 中提到的 <strong>partial evaluation friendly</strong> 的意思?</li>
</ul>
<h2 id="function-unfolding-strategy">Function Unfolding Strategy</h2>
<p>unfold 可以消除一些函数定义让residual program变得更简洁,
比如说下面的两种函数显然可以被unfold:</p>
<ol>
<li>一个函数什么也没做, 只是调用另一个函数;</li>
<li>一个函数只被调用过一次.</li>
</ol>
<p>之前提到的unfolding strategy只有在 <code>calls</code> 的目标没有动态参数的时候会进行unfold,
然而unfold strategy的其实可以是比较复杂的.
unfold strategy的最终目的还是为了提升residual程序的质量(比如说消除trivial function).
而在这个过程中,
有可能因为unfold反而降低了程序质量(产生了program duplication或computation duplication),
又有各种各样的trick.
这里就不详细介绍每个strategy了, 只介绍一些通用的unfolding strategy的基本要求:</p>
<ol>
<li>实参的计算存在副作用, 则需要保证这些副作用的顺序&amp;次数在unfold后的程序中不变;</li>
<li>要保证unfold策略能够停机, 不会无限的unfold;</li>
<li>尽量避免unfold过程中的program duplication和computation duplication.</li>
</ol>
<h2 id="related-notes-resource">Related Notes/Resource</h2>
<p><a href="https://www.itu.dk/people/sestoft/pebook/">ND.Jones&rsquo;s book</a>: Partial Evaluation的教材</p>
<p><a href="/articles/partial-evaluation/">Partial Evaluation</a>: Partial Evaluation的基本概念</p>
<p><a href="/articles/partial-evaluation-for-flow-chart/">Partial Evaluation For Flow Chart Langauge</a>: Flow chart语言的Partial Evaluation</p>
<p><a href="/404">Abstract Interpretation</a>: 抽象解释</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
